if __name__ == '__main__':
    from ursina import *
    app = Ursina()
    t = load_texture('level_1')
    data = t.pixels.tolist()
    print(data)
    with open('test.js', 'w') as f:
        f.write('level_1 = ' + str(data))

    # app.run()
'''

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>tile rpg</title><link rel="stylesheet" href="../taptapir.css"></head><body></body><script src="../taptapir.js"></script>
<script src="test.js"></script>
<script type='text/pokescript'>

set_window_color('rgb(49 72 60)')
w = 8
h = 8
tiles = Array_2d(w+1,h+1)

level_parent = Entity(scale=1/w, position=[0,0], visible_self=False)
tiles_parent = Entity(parent=level_parent, visible_self=False)
for y in range(9):
    for x in range(w+1):
        // print(x,y)
        tiles[x][y] = Entity(parent=tiles_parent, position=[x-4-1,y-4-1], origin=[-.5,-.5], color=rgb(x*.1,y*.1,1), scale=1.01)

// player = Entity(scale=1/8*.75, color='red', shadow=True,origin=[-.5,-.5])
player = Entity(scale=1/8*.75, texture='nobyl_pixely_big.png', shadow=False, origin=[-.5,-.5], collision=False)

def set_start_position(x, y):
    grid_x = x
    grid_y = y
    prev_grid_x = x
    prev_grid_y = y
    level_parent.xy = [-x/8, -y/8]
    tiles_parent.xy = [x, y]
    // update_tiles()

for y in range(64):
    for x in range(64):
        col = level_1[y][x]
        if col[0] == 0 and col[1] == 255 and col[2] == 0:
            set_start_position(x-5, y-5)

update_tiles()

circle = Entity(roundness=.5, scale=.25, color='darkgray', y=-.7, x=-.3)
inner_circle = Entity(roundness=.5, scale=.125, color=rgb(49, 72, 60), xy=circle.xy)
e = Entity(roundness=.5, scale=.15, color='black', xy=circle.xy, z=-1, draggable=True, min_x=circle.x-.125, max_x=circle.x+.125, min_y=circle.y-.125, max_y=circle.y+.125, shadow=True)
e.update = def():
    if not e.dragging:
        return
    dir = [(e.x - circle.x)/.125, (e.y - circle.y)/.125]
    mag = magnitude(dir)
    if mag < .125:
        return

    dir = normalize(dir)
    movement_speed = .005
    // player.x += dir[0] * movement_speed
    // player.y += dir[1] * movement_speed


    level_parent.x -= dir[0] * movement_speed
    level_parent.y -= dir[1] * movement_speed

    grid_x = -floor(level_parent.x*8)
    grid_x = clamp(grid_x, 0, 64-2)
    dir = grid_x - prev_grid_x
    if dir == 1:
        tiles_parent.x += 1
        update_tiles()
    elif dir == -1:
        tiles_parent.x -= 1
        update_tiles()

    prev_grid_x = grid_x


    grid_y = -floor(level_parent.y*8)
    grid_y = clamp(grid_y, 0, 64-2)
    dir = grid_y - prev_grid_y
    if dir == 1:
        tiles_parent.y += 1
        update_tiles()
    elif dir == -1:
        tiles_parent.y -= 1
        update_tiles()

    prev_grid_y = grid_y



e.drop = def():
    e.xy = circle.xy


def update_tiles():
    for y in range(9):
        for x in range(9):
            col = level_1[clamp(grid_y + y, 0, 64-1)][clamp(grid_x + x, 0, 64-1)]
            print(grid_x + x, grid_y + y, col)
            tiles[x][y].color = rgb(col[0], col[1], col[2])

            // if col[0] == 0 and col[1] == 255 and col[2] == 0:
            //     set_start_position(gridx+x, grid_y+y)
            // if col === [0,0,0]:
            //     tiles[x][y].color = 'black'
            // else:
            //     tiles[x][y].color = 'cyan'



</script><script src="../pokescript_compiler.js"></script></html>
'''
