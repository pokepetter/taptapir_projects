if __name__ == '__main__':
    from ursina import *
    app = Ursina()
    t = load_texture('level_1')
    data = t.pixels.tolist()

    with open('test.js', 'w') as f:
        f.write('level_1 = ' + str(data))

'''

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>tile rpg</title><link rel="stylesheet" href="../taptapir.css"></head><body></body><script src="../taptapir.js"></script>
<script src="test.js"></script>
<script type='text/pokescript'>

set_window_color('rgb(49 72 60)')
set_background_color('rgb(49 72 60)')
width = 8
height = 11
tiles = Array_2d(width+5, height+5)
tiles_flat = []

camera.fov = 8.9
tiles_parent = Entity(visible_self=False)
for y in range(height+5):
    for x in range(width+5):
        tiles[x][y] = Entity(parent=tiles_parent, position=[x-6,y-6], color=rgb(x*.1,y*.1,1), scale=1.02)
        tiles_flat.append(tiles[x][y])

player = Entity(scale=1, texture='nobyl_pixely_big.png', collision=False, origin=[0,-.5])
// player = Entity(scale=1, color='cyan', collision=False, roundness=.5)

grid_x = 0
grid_y = 0
prev_grid_x = 0
prev_grid_y = 0
def set_start_position(x, y):
    grid_x = x
    grid_y = y
    prev_grid_x = x
    prev_grid_y = y
    player.xy = [x, y]
    tiles_parent.xy = player.xy
    camera.xy = player.xy
    // print('-----------', player.xy)


for y in range(64):
    for x in range(64):
        col = level_1[y][x]
        if col[0] == 0 and col[1] == 255 and col[2] == 0:
            set_start_position(x-6, y-6)
// set_start_position(32, 9)
// set_start_position(level_1_start_position[0], level_1_start_position[1])
update_tiles()

ui_bg = Entity(parent=camera, origin=[0,.5], color='#123', z=1, scale=1.1, y=-.49, shadow=True)
circle = Entity(parent=camera, roundness=.5, scale=.25, color='darkgray', y=-.7, x=-.3)
inner_circle = Entity(parent=camera, roundness=.5, scale=.125, color=rgb(49, 72, 60), xy=circle.xy)
e = Entity(parent=camera, roundness=.5, scale=.15, color='black', xy=circle.xy, z=-1, draggable=True, min_x=circle.x-.125, max_x=circle.x+.125, min_y=circle.y-.125, max_y=circle.y+.125, shadow=True)
// collider_hel

e.update = def():
    if not e.dragging:
        return
    dir = [(e.x - circle.x)/.125, (e.y - circle.y)/.125]
    mag = magnitude(dir)
    if mag < .125:
        return

    norm_dir = normalize(dir)
    movement_speed = 4
    move_amount = [dir[0] * movement_speed * delta_time, dir[1] * movement_speed * delta_time]
    min_x = 0
    max_x = 64
    min_y = 0
    max_y = 64

    middle_tile = tiles[6][6]
    // middle_tile.color = 'red'
    if tiles[5][6].solid and player.world_x <= middle_tile.world_x:
        // min_x = middle_tile.world_x
        move_amount[0] = max(move_amount[0], 0)

    if tiles[7][6].solid and player.world_x > middle_tile.world_x:
        move_amount[0] = min(move_amount[0], 0)

    if tiles[6][5].solid and player.world_y <= middle_tile.world_y:
        move_amount[1] = max(move_amount[1], 0)

    if tiles[6][7].solid and player.world_y > middle_tile.world_y:
        move_amount[1] = min(move_amount[1], 0)

    // if tiles[4][4].solid and player.world_x < middle_tile.world_x:
    //     move_amount[0] = max(move_amount[0], 0)
        // player.x = max(player.x, middle_tile.world_x)
        // player.y = max(player.y, middle_tile.world_y)
        // min_x = tiles[4][4].world_x + 1
        // min_y = tiles[4][4].world_y + 0

    player.x += move_amount[0]
    player.y += move_amount[1]
    player.x = clamp(player.x, min_x, max_x)


    grid_x = round(player.x)
    grid_x = clamp(grid_x, 0, 64-1)
    grid_y = round(player.y)
    grid_y = clamp(grid_y, 0, 64-1)

    if grid_x != prev_grid_x or grid_y != prev_grid_y:
        tiles_parent.x = grid_x
        tiles_parent.y = grid_y
        prev_grid_x = grid_x
        prev_grid_y = grid_y
        update_tiles()



def intersects(rect1, rect2):
    return (rect1.world_x < rect2.world_x + rect2.world_scale_x and rect1.world_x + rect1.world_scale_x > rect2.world_x and rect1.world_y < rect2.world_y + rect2.world_scale_y and rect1.world_scale_y + rect1.world_y > rect2.world_y)

def point_intersects(point, entity):
    half_w = entity.world_scale_x / 2
    half_h = entity.world_scale_y / 2
    return point[0] > entity.world_x-half_w and point[0] < entity.world_x+half_w and point[1] > entity.world_y-half_h and point[1] < entity.world_y+half_h


e.drop = def():
    e.xy = circle.xy
camera_mover = Entity(visible_self=False)
camera_mover.update = def():
    camera.x = lerp(camera.x, player.x, .1)
    camera.y = lerp(camera.y, player.y, .1)


for y in range(64):
    for x in range(64):
        if not level_1[x][y][1] == 0:
            // level_1[x][y] = [255,0,0]
            continue

        top_solid =   x == 0 or level_1[x-1][y][1] == 0
        left_solid =    y == 0 or level_1[x][y-1][1] == 0
        bot_solid = x == 63 or level_1[x+1][y][1] == 0
        right_solid =   y == 63 or level_1[x][y+1][1] == 0

        if top_solid and right_solid and bot_solid and left_solid:
            // level_1[x][y] = [32,0,32]
            // tiles[x][y].text='u'
            continue

        if not top_solid:
            if left_solid and right_solid:
                level_1[x][y] = [255,0,128]
                // tiles[x][y].text='t'
                continue
            if not left_solid:
                level_1[x][y] = [255,0,128]
                // tiles[x][y].text='tl'
                continue
            else:
                level_1[x][y] = [255,0,128]
                // tiles[x][y].text='tr'
                continue

        if not bot_solid:
            if left_solid and right_solid:
                // level_1[x][y] = [0,0,0]
                // tiles[x][y].text='b'
                continue
            if right_solid:
                // tiles[x][y].text='bl'
                continue
            else:
                // tiles[x][y].text='br'
                continue

        if left_solid:
            // level_1[x][y] = [255,0,255]
            // tiles[x][y].text='l'
            continue
        else:
            // level_1[x][y] = [0,0,0]
            // tiles[x][y].text='r'
            continue

// print(level_1)

def update_tiles():
    for y in range(height+5):
        for x in range(width+5):
            tile_coord = level_1[clamp(grid_y + y, 0, 64-1)][clamp(grid_x + x, 0, 64-1)]
            // print(tile_coord, clamp(grid_y + y, 0, 64-1), clamp(grid_x + x, 0, 64-1))
            // tiles[x][y].solid = tile_coord[1] == 0
            tiles[x][y].solid = tile_coord[1] == 0
            tiles[x][y].color = rgb(tile_coord[0]/255, tile_coord[1]/255, tile_coord[2]/255)

            // if not tiles[x][y].solid:
            //     tiles[x][y].color = 'gray'
            // else:
            //     tiles[x][y].color = 'black'

    // for y in range(0, height+5):
    //     for x in range(0, width+5):
    //         tiles[x][y].text = ''
    //         if not tiles[x][y].solid:
    //             continue
    //
    //         left_solid = x == 0 or tiles[x-1][y].solid
    //         bot_solid =  y == 0 or tiles[x][y-1].solid
    //         right_solid = x == width+4 or tiles[x+1][y].solid
    //         top_solid =  y == height+4 or tiles[x][y+1].solid
    //
    //         if top_solid and right_solid and bot_solid and left_solid:
    //             // tiles[x][y].text='u'
    //             continue
    //
    //         if not top_solid:
    //             if left_solid and right_solid:
    //                 // tiles[x][y].text='t'
    //                 continue
    //             if not left_solid:
    //                 // tiles[x][y].text='tl'
    //                 continue
    //             else:
    //                 // tiles[x][y].text='tr'
    //                 continue
    //
    //         if not bot_solid:
    //             tiles[x][y].color='darkgray'
    //
    //             if left_solid and right_solid:
    //                 // tiles[x][y].text='b'
    //                 continue
    //             if right_solid:
    //                 // tiles[x][y].text='bl'
    //                 continue
    //             else:
    //                 // tiles[x][y].text='br'
    //                 continue
    //
    //         if not left_solid:
    //             // tiles[x][y].text='l'
    //             continue
    //         else:
    //             // tiles[x][y].text='r'
    //             continue

update_tiles()
</script><script src="../pokescript_compiler.js"></script></html>
'''
