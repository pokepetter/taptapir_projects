if __name__ == '__main__':
    from ursina import *
    app = Ursina()
    t = load_texture('level_1')
    data = t.pixels.tolist()
    print(data)
    with open('test.js', 'w') as f:
        f.write('level_1 = ' + str(data))

    # app.run()
'''

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>tile rpg</title><link rel="stylesheet" href="../taptapir.css"></head><body></body><script src="../taptapir.js"></script>
<script src="test.js"></script>
<script type='text/pokescript'>

set_window_color('rgb(49 72 60)')
width = 8
height = 11
tiles = Array_2d(width+3, height+3)
tiles_flat = []

camera.fov = 7.9
tiles_parent = Entity(visible_self=False)
for y in range(height+3):
    for x in range(width+3):
        tiles[x][y] = Entity(parent=tiles_parent, position=[x-5,y-5], color=rgb(x*.1,y*.1,1), scale=1.02)
        tiles_flat.append(tiles[x][y])

player = Entity(scale=1, texture='nobyl_pixely_big.png', collision=False)
// player = Entity(scale=1, color='cyan', collision=False, roundness=.5)

def set_start_position(x, y):
    grid_x = x
    grid_y = y
    prev_grid_x = x
    prev_grid_y = y
    player.xy = [x, y]
    tiles_parent.xy = player.xy
    camera.xy = player.xy

for y in range(64):
    for x in range(64):
        col = level_1[y][x]
        if col[0] == 0 and col[1] == 255 and col[2] == 0:
            set_start_position(x-4, y-4+8)
// set_start_position(0, 0)
update_tiles()

ui_bg = Entity(parent=camera, origin=[0,.5], color='#123', z=1, scale=1.1, y=-.49, shadow=True)
circle = Entity(parent=camera, roundness=.5, scale=.25, color='darkgray', y=-.7, x=-.3)
inner_circle = Entity(parent=camera, roundness=.5, scale=.125, color=rgb(49, 72, 60), xy=circle.xy)
e = Entity(parent=camera, roundness=.5, scale=.15, color='black', xy=circle.xy, z=-1, draggable=True, min_x=circle.x-.125, max_x=circle.x+.125, min_y=circle.y-.125, max_y=circle.y+.125, shadow=True)
min_x = 0
max_x = 64
min_y = 0
max_y = 64
// collider_hel

def intersects(point, entity):
    return point[0] > (entity.world_x - entity.world_scale_x/2) and point[0] < (entity.world_x + entity.world_scale_x/2) and point[1] > (entity.world_y - entity.world_scale_y/2) and point[1] < (entity.world_y + entity.world_scale_y/2)
helper = Entity(scale=.05, color='green', roundness=.5)
player.collider = Entity(parent=player, visible_self=False, z=.1)

e.update = def():
    if not e.dragging:
        return
    dir = [(e.x - circle.x)/.125, (e.y - circle.y)/.125]
    mag = magnitude(dir)
    if mag < .125:
        return

    norm_dir = normalize(dir)
    movement_speed = 4
    move_amount = [dir[0] * movement_speed * delta_time, dir[1] * movement_speed * delta_time]

    player.collider.xy = move_amount

    min_x = 0
    max_x = 64
    min_y = 0
    max_y = 64

    middle_tile = tiles[5][5]
    // middle_tile.color = 'red'
    if tiles[4][5].solid:
        min_x = middle_tile.world_x - 0
    if tiles[6][5].solid and player.collider.world_x > middle_tile.world_x:
        move_amount[0] = 0
    if tiles[5][4].solid:
        min_y = middle_tile.world_y +0
    if tiles[5][6].solid and player.collider.world_y > middle_tile.world_y:
        move_amount[1] = 0

    player.x += move_amount[0]
    player.y += move_amount[1]
    player.x = clamp(player.x, min_x, max_x)
    player.y = clamp(player.y, min_y, max_y)


    grid_x = round(player.x)
    grid_x = clamp(grid_x, 0, 64-1)
    grid_y = round(player.y)
    grid_y = clamp(grid_y, 0, 64-1)

    if grid_x != prev_grid_x or grid_y != prev_grid_y:
        tiles_parent.x = grid_x
        tiles_parent.y = grid_y
        prev_grid_x = grid_x
        prev_grid_y = grid_y
        update_tiles()



def intersects(rect1, rect2):
    return (rect1.world_x < rect2.world_x + rect2.world_scale_x and rect1.world_x + rect1.world_scale_x > rect2.world_x and rect1.world_y < rect2.world_y + rect2.world_scale_y and rect1.world_scale_y + rect1.world_y > rect2.world_y)

def point_intersects(point, entity):
    half_w = entity.world_scale_x / 2
    half_h = entity.world_scale_y / 2
    return point[0] > entity.world_x-half_w and point[0] < entity.world_x+half_w and point[1] > entity.world_y-half_h and point[1] < entity.world_y+half_h


e.drop = def():
    e.xy = circle.xy
camera_mover = Entity(visible_self=False)
camera_mover.update = def():
    camera.x = lerp(camera.x, player.x, .1)
    camera.y = lerp(camera.y, player.y, .1)


def update_tiles():
    for y in range(height+3):
        for x in range(width+3):
            col = level_1[clamp(grid_y + y, 0, 64-1)][clamp(grid_x + x, 0, 64-1)]
            tiles[x][y].solid = col[1] == 0
            tiles[x][y].color = rgb(col[0], col[1], col[2])

            // if col[0] == 0 and col[1] == 255 and col[2] == 0:
            //     set_start_position(gridx+x, grid_y+y)

// Entity(visible_self=False).update = def():
//     print(1/delta_time)

</script><script src="../pokescript_compiler.js"></script></html>
'''
