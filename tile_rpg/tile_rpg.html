if __name__ == '__main__':
    from ursina import *
    app = Ursina()
    t = load_texture('level_1')
    data = t.pixels.tolist()
    print(data)
    with open('test.js', 'w') as f:
        f.write('level_1 = ' + str(data))

    # app.run()
'''

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>tile rpg</title><link rel="stylesheet" href="../taptapir.css"></head><body></body><script src="../taptapir.js"></script>
<script src="test.js"></script>
<script type='text/pokescript'>

set_window_color('rgb(49 72 60)')
width = 8
height = 11
tiles = Array_2d(width+2, height+2)

camera.fov = 7.9
tiles_parent = Entity(visible_self=False)
for y in range(height+2):
    for x in range(width+2):
        tiles[x][y] = Entity(parent=tiles_parent, position=[x-4,y-4], origin=[-.5,-.5], color=rgb(x*.1,y*.1,1), scale=1.02)

// player = Entity(scale=1, texture='nobyl_pixely_big.png', origin=[-.5,-.5], collision=False)
player = Entity(scale=1, color='cyan', origin=[-.5,-.5], collision=False)

def set_start_position(x, y):
    grid_x = x
    grid_y = y
    prev_grid_x = x
    prev_grid_y = y
    player.xy = [x, y]
    tiles_parent.xy = player.xy
    camera.xy = player.xy

for y in range(64):
    for x in range(64):
        col = level_1[y][x]
        if col[0] == 0 and col[1] == 255 and col[2] == 0:
            set_start_position(x-4, y-4+8)
// set_start_position(0, 0)
update_tiles()

ui_bg = Entity(parent=camera, origin=[0,.5], color='#123', z=1, scale=1.1, y=-.49, shadow=True)
circle = Entity(parent=camera, roundness=.5, scale=.25, color='darkgray', y=-.7, x=-.3)
inner_circle = Entity(parent=camera, roundness=.5, scale=.125, color=rgb(49, 72, 60), xy=circle.xy)
e = Entity(parent=camera, roundness=.5, scale=.15, color='black', xy=circle.xy, z=-1, draggable=True, min_x=circle.x-.125, max_x=circle.x+.125, min_y=circle.y-.125, max_y=circle.y+.125, shadow=True)
min_x = 0
max_x = 64
min_y = 0
max_y = 64
e.update = def():
    if not e.dragging:
        return
    dir = [(e.x - circle.x)/.125, (e.y - circle.y)/.125]
    mag = magnitude(dir)
    if mag < .125:
        return

    // dir = normalize(dir)
    movement_speed = 4
    move_amount = [dir[0] * movement_speed * delta_time, dir[1] * movement_speed * delta_time]

    target_pos = [player.x + move_amount[0], player.y + move_amount[1]]
    // org_pos = player.xy
    // for e in neighbors:
    //     // print(distance(e.world_position, target_pos))
    //     if e.solid and distance(e.world_position, target_pos) < .1:
    //         return

    player.x += move_amount[0]
    player.y += move_amount[1]
    // left_tile = floor(player.x + move_amount[0])
    // print(left_tile)
    // if dir[0] < 0:
    //     player.x += move_amount[0]
    // if point_intersects(player.xy, tiles[4][4]):
    //     print('solid')
    // else:
    //     print('air')
    player.x = clamp(player.x, min_x, max_x)
    player.y = clamp(player.y, min_y, max_y)


    grid_x = floor(player.x)
    grid_x = clamp(grid_x, 0, 64-1)
    grid_y = floor(player.y)
    grid_y = clamp(grid_y, 0, 64-1)

    tiles[4][4].color = 'red'
    // print(tiles[3][4].color)
    avoid_grid(dir)

    if grid_x != prev_grid_x or grid_y != prev_grid_y:
        tiles_parent.x = grid_x
        tiles_parent.y = grid_y
        prev_grid_x = grid_x
        prev_grid_y = grid_y
        update_tiles()

dir_n = tiles[4][4+1]
dir_ne = tiles[4+2][4+1]
dir_e = tiles[4+2][4]
dir_se = tiles[4+1][4-1]
dir_s = tiles[4][4-1]
dir_sw = tiles[4-1][4-1]
dir_w = tiles[4-1][4]
dir_nw = tiles[4][4+1]
neighbors = [dir_n, dir_ne, dir_e, dir_se, dir_s, dir_sw, dir_w, dir_nw]
def avoid_grid(dir):
    // for e in neighbors:
    //     print(e.solid)
    min_x = 0
    if dir_w.solid and (player.y >= dir_w.world_y or player.y <= dir_w.world_y+1):
        dir_w.color = 'orange'
        min_x = dir_w.x + tiles_parent.x + 1
    elif dir_nw.solid and (player.y >= dir_nw.world_y or player.y <= dir_nw.world_y+1):
        min_x = dir_nw.x + tiles_parent.x + 1

    max_x = 64
    if dir_e.solid and (player.y >= dir_e.world_y or player.y <= dir_e.world_y+1):
        dir_e.color = 'blue'
        max_x = dir_e.x + tiles_parent.x - 1.01
    elif dir_ne.solid and (player.y >= dir_ne.world_y or player.y <= dir_ne.world_y+1):
        max_x = dir_ne.x + tiles_parent.x - 1.01


    min_y = 0
    // dir_se.color = 'red'
    if dir_s.solid and (player.x >= dir_s.world_x or player.x <= dir_s.world_x+1):
        dir_s.color = 'red'
        min_y = dir_s.y + tiles_parent.y + 1
    elif dir_se.solid and (player.x >= dir_se.world_x or player.x <= dir_se.world_x+1):
        min_y = dir_se.y + tiles_parent.y + 1

    max_y = 64
    dir_n.color = 'blue'
    tiles[4+1][4+1].color = 'violet'
    if dir_n.solid and (player.x >= dir_n.world_x or player.x < dir_n.world_x+1):
        max_y = dir_n.y + tiles_parent.y - 1
    // elif tiles[4+1][4+1].solid and (player.x >= dir_nw.world_x or player.x < dir_nw.world_x+1):
    //     max_y = dir_nw.y + tiles_parent.y - 1



e.drop = def():
    e.xy = circle.xy
camera_mover = Entity(visible_self=False)
camera_mover.update = def():
    camera.x = lerp(camera.x, player.x, .1)
    camera.y = lerp(camera.y, player.y, .1)


def update_tiles():
    for y in range(height+2):
        for x in range(width+2):
            col = level_1[clamp(grid_y + y, 0, 64-1)][clamp(grid_x + x, 0, 64-1)]
            tiles[x][y].solid = col[1] == 0
            tiles[x][y].color = rgb(col[0], col[1], col[2])

            // if col[0] == 0 and col[1] == 255 and col[2] == 0:
            //     set_start_position(gridx+x, grid_y+y)

// Entity(visible_self=False).update = def():
//     print(1/delta_time)

</script><script src="../pokescript_compiler.js"></script></html>
'''
