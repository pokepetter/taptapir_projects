<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8" />
    <!-- <link rel="manifest" href="/manifest.json"> -->
    <title>dreamland sketcher</title>
    <link rel="stylesheet" href="../taptapir.css">
</head>
<body></body>

<script src="color_conversion.js"></script>
<script src="../taptapir.js"></script>
</html>
<script type='text/sunsnake'>

set_window_color('#222')
set_background_color('#111')


var canvas = document.createElement('canvas');
# canvas.style.pointerEvents = 'auto'
canvas.style.width= '100%'
canvas.style.height= '100%'
canvas.style.top= '0%'
canvas.style.bottom= '10%'
canvas.style.pointerEvents = 'none'
canvas.style.boxShadow = "3px 10px 20px #111";


set_orientation('horizontal')
# set_scale(.66)
set_scale(1)
canvas_scale = .8
var w = 1080
var h = 1920
var h = 1080*1;
var w = 1920*1;
canvas_entity = Entity(color=color.clear, scale_x=aspect_ratio, draggable=True, lock_x=True, lock_y=True)
canvas_entity.el.id = 'canvas_entity'
canvas_entity.model.appendChild(canvas)
canvas_entity.origin = [0,0]
canvas_entity.scale_y = 1 * canvas_scale
canvas_entity.scale_x = 1 * canvas_scale * aspect_ratio
# canvas_entity.y = .075
# set_fullscreen(True)
# set_scale(.4)
print('aspect_ratio:', aspect_ratio)

canvas.width = w
canvas.height = h

ctx = canvas.getContext('2d')
ctx.fillStyle = rgb(128/255, 128/255, 128/255, 255/255)
ctx.fillRect(0, 0, canvas.width, canvas.height)

round_brush = {'textures':["round_brush_16.png", ], 'size':[2, 2], 'spacing':.5, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True}
poke_brush = {'textures':["pokebrush.png", ], 'size':[256, 256], 'spacing':.075, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True}
painterly_brush = {'textures':["RGBA anim 01.png", "RGBA anim 02.png", "RGBA anim 03.png", "RGBA anim 04.png", ], 'size':[178, 400], 'spacing':.5, 'painterly_brush':True, 'rotate':True, 'draw_on_click':False}

brushes = [round_brush, poke_brush, painterly_brush]

def set_brush(brush):
    brush_tips = [new Image() for e in brush.textures]
    for i in range(brush_tips.length):
        brush_tips[i].src = brush.textures[i]

    brush_size = brush.size
    SPACING = brush.spacing
    using_painterly_brush = brush.painterly_brush
    rotate_brush = brush.rotate
    draw_on_click = brush.draw_on_click


set_brush(painterly_brush)
img = new Image()
brush_canvases = [document.createElement('canvas') for i in range(brush_tips.length)]
current_color = [255, 0, 128, 255]
# current_color = [0, 0, 0, 255]
drawing = False
using_eyedropper = False
prev_pos = None

cursor = Entity(scale=.02, color=color.red, alpha=.1, parent=canvas_entity, enabled=false)
zoom_label = Button(text='100%', scale=[.075,.04], origin=[.5,.5], xy=[(.5*aspect_ratio)-.005,.495], color=hsv(0,0,0), text_color=hsv(0,0,.8), text_size=2, on_click=def():target_zoom=[aspect_ratio,1])
smoothing = false

# def get_canvas_position():
#     x = (.5 + (mouse.x / .88)) * w
#     # y = (.5 -((mouse.y / .88 / aspect_ratio) - .05)) * w*aspect_ratio
#     y = (.5 -((mouse.y / .88 / aspect_ratio))) * w * aspect_ratio * 2
#     # cursor.position = [x,y]
#
#     return [Math.floor(x), Math.floor(y)]


start_position = null
snap_to_hex = false

canvas_entity.on_click = def():
    if using_lasso_tool:
        return

    if not held_keys['shift']:
        prev_pos = None

    if not using_painterly_brush:
        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            brush = brush_tips[j]

            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            brush_canvas_context = brush_canvas.getContext("2d")
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            imgData = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

            for i in range(0, imgData.data.length, 4):
                imgData.data[i] = imgData.data[i] * (current_color[0]/255)
                imgData.data[i+1] = imgData.data[i+1] * (current_color[1]/255)
                imgData.data[i+2] = imgData.data[i+2] * (current_color[2]/255)
                imgData.data[i+3] = imgData.data[i+3] * (current_color[3]/255)

            brush_canvas_context.putImageData(imgData, 0, 0)
    else:
        color_as_hsv = rgb_to_hsv(current_color)
        c = color_as_hsv[2] * 255
        c = (current_color[0] + current_color[1] + current_color[2])/3
        # print('------------', c)
        sat = color_as_hsv[1]
        contrast = 64
        dark = c-contrast
        light = c+contrast
        # adjust contrast and brighten based on saturation
        dark = c-contrast + (sat*contrast*1.2)
        light = c+contrast + contrast + (sat*contrast*1.2)

        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            # print(typeof(brush_canvases[j]))
            brush = brush_tips[j]

            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            brush_canvas_context = brush_canvas.getContext("2d")
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            imgData = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

            for i in range(0, imgData.data.length, 4):
                # imgData.data[i] = lerp(dark, light, imgData.data[i]/255) * lerp(1, current_color[0]/255, sat)
                # imgData.data[i+1] = lerp(dark, light, imgData.data[i+1]/255) * lerp(1, current_color[1]/255, sat)
                # imgData.data[i+2] = lerp(dark, light, imgData.data[i+2]/255) * lerp(1, current_color[2]/255, sat)
                imgData.data[i] = lerp(dark, light, imgData.data[i]/255) * current_color[0]/255
                imgData.data[i+1] = lerp(dark, light, imgData.data[i+1]/255) * current_color[1]/255
                imgData.data[i+2] = lerp(dark, light, imgData.data[i+2]/255) * current_color[2]/255
                imgData.data[i+3] = imgData.data[i+3] * current_color[3]/255

            brush_canvas_context.putImageData(imgData, 0, 0)

    if not using_eyedropper:
        drawing = True
    try:
        paint()
    catch:
        return

brush_distance = 0
draw_on_click = False
rotate_brush = True
using_painterly_brush = True
prev_brush_tip = -1

opacity_keys = '|1234567890'.split('')
target_zoom = canvas_entity.scale

def input(key):
    # print(key)
    for i, e in enumerate(opacity_keys):
        if key == e:
            current_color[3] = int(255/10 * i)
            print(current_color)

    if key == 'alt':
        using_eyedropper = True

    if key == 'alt up':
        using_eyedropper = False

    if held_keys['control'] and key == 'z':
        undo()

    if held_keys['control'] and key == 'y':
        redo()

    if key == 'd':
        # brush_size *= 1.5
        brush_size = [e * 1.5 for e in brush_size]

    if key == 'x':
        # brush_size /= 1.5
        brush_size = [e / 1.5 for e in brush_size]

    if key == 'h':
        print(event)
        snap_to_hex = True

    if key == 'r':
        current_color = [255, 0, 0, 255]


    if key == 's':
        smoothing = True
    elif key == 's up':
        smoothing = False

    if key == 'scroll down':
        target_zoom = [e*.9 for e in target_zoom]
        zoom_label.text = `${int(target_zoom[1]*100)}%`
    if key == 'scroll up':
        target_zoom = [e*1/.9 for e in target_zoom]
        zoom_label.text = `${int(target_zoom[1]*100)}%`

    if key == 'middle mouse down' or key == 'space':
        canvas_entity.lock_x = False
        canvas_entity.lock_y = False
        canvas_entity.start_offset = [mouse.x-canvas_entity.x , mouse.y-canvas_entity.y]
        canvas_entity.dragging = True

    if key == 'middle mouse up' or key == 'space up':
        canvas_entity.lock_x = True
        canvas_entity.lock_y = True
        canvas_entity.dragging = False

def update():
    canvas_entity.scale_x = lerp(canvas_entity.scale[0], target_zoom[0], .2)
    canvas_entity.scale_y = lerp(canvas_entity.scale[1], target_zoom[1], .2)


def paint():
    if not drawing and not using_eyedropper:
        return
    if mouse.hovered_entity != canvas_entity:
        return

    pos = mouse.point

    # print('PAINT', mouse.point)
    var x = (pos[0]+.5) * w
    var y = (pos[1]-.5) * -h
    if smoothing and prev_pos:
        x = lerp(prev_pos[0], x, .025)
        y = lerp(prev_pos[1], y, .025)

    if using_eyedropper:
        current_color = ctx.getImageData(x, y, 1, 1).data
        set_color(current_color)
        return

    # print('--------------', prev_pos)
    if prev_pos == None:
        prev_brush_tip += 1
        if prev_brush_tip >= brush_tips.length:
            prev_brush_tip = 0
        img.src = brush_canvases[prev_brush_tip].toDataURL()

        # print('prev_brush_tip', prev_brush_tip, x ,y)
        # ctx.drawImage(img, x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
        if draw_on_click:
            invoke(def anon():
                ctx.drawImage(img, x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
            , delay=0)

        start_position = pos
        prev_draw_pos = pos
        prev_pos = [x,y]
        pixels_traveled = 0
        return

    if snap_to_hex:
        y = start_position[1] + (x-start_position[0])

    # print('--------', prev_pos)
    distance_since_last_frame = distanceApprox(prev_pos, [x,y])
    pixels_traveled += distance_since_last_frame
    spacing_in_pixels = brush_size[1]*SPACING
    steps = floor(pixels_traveled / spacing_in_pixels)

    delta_pos = [x - prev_pos[0], y - prev_pos[1]]
    radians = -math.atan2(delta_pos[0], delta_pos[1])
    # if steps:
    #     print('--------------', steps, spacing_in_pixels, pixels_traveled)

    for i in range(0, steps):
        prev_brush_tip += 1
        if prev_brush_tip >= brush_tips.length:
            prev_brush_tip = 0

        t = i / steps
        let _x = lerp(prev_pos[0], x, t)
        let _y = lerp(prev_pos[1], y, t)

        img.src = brush_canvases[prev_brush_tip].toDataURL()

        if not rotate_brush:
            ctx.drawImage(img, _x-(brush_size[0]/2), _y-(brush_size[1]/2), brush_size[0], brush_size[1])

        else:
            invoke(def anon():
                ctx.translate(_x, _y)
                ctx.rotate(radians)
                ctx.drawImage(img, -brush_size[0]/2, -brush_size[1]/2)
                ctx.rotate(-radians)
                ctx.translate(-_x, -_y)
            , delay=0)

        prev_draw_pos = [_x, _y]

    pixels_traveled -= steps * spacing_in_pixels
    prev_pos = [x, y]
    # prev_pos_for_line_draw_mode = [x, y]
    # if not held_keys['shift']:

canvas_entity.while_dragging = paint


def mouse_up(ev):
    if drawing:
        record_undo()

    drawing = false
    # if not held_keys['shift']:
    #     prev_pos = None
    #     print('reset')


document.addEventListener("mouseup", mouse_up, false)
document.addEventListener("touchend", mouse_up, false)
var canvas_rect = canvas.getBoundingClientRect()

# Approximation by using octagons approach
def distanceApprox(p1,p2):
    var x = p2[0]-p1[0]
    var y = p2[1]-p1[1]
    return 1.426776695*Math.min(0.7071067812*(Math.abs(x)+Math.abs(y)), Math.max(Math.abs(x), Math.abs(y)))



color_menu = Entity(parent=camera.ui, visible_self=False, position=[.465,-.451,-1])
color_menu.menu = Entity(parent=color_menu, visible_self=False, enabled=True, scale=.3)

# def color_menu_input(key):
#     if key == 'c':
#         color_menu.menu.enabled = not color_menu.menu.enabled
# color_menu.input = color_menu_input

slider_height = .075
bg = Entity(parent=color_menu.menu, x=.15, scale=[1.05+.3, (slider_height*1.1*3)+.05], color='#000f', alpha=.8, roundness=.05, z=2)
color_preview = Entity(parent=color_menu.menu, scale=slider_height*3*1.1, x=.55, origin=[-.5,0], roundness=.5)

compiler.define(*slider_style, scale_y=.075, roundness=.15, draggable=True, lock_x=True, lock_y=True)

hue_slider = Entity(*slider_style, parent=color_menu.menu, y=slider_height*1.1, texture='rainbow.png')
hue_slider.indicator = Entity(parent=hue_slider, scale_x=.01, color=color.black, z=-2)
hue_slider.on_click = def():
    hue_slider.indicator.x = mouse.point[0]

    _curr_color = rgb_to_hsv(current_color)
    value = (mouse.point[0]+.5) * 360
    color_as_rgb = hsv(value, _curr_color[1], _curr_color[2])
    current_color[0] = color_as_rgb[0]
    current_color[1] = color_as_rgb[1]
    current_color[2] = color_as_rgb[2]
    # print('----------------', current_color)
    set_color(current_color, False)
    # print('set hue:', value)
hue_slider.while_dragging = hue_slider.on_click

sat_slider = Entity(*slider_style, parent=color_menu.menu, y=0)
sat_slider.overlay = Entity(parent=sat_slider, texture='horizontal_gradient.png', y=0, z=-1, roundness=.15)
sat_slider.indicator = Entity(parent=sat_slider, scale_x=.01, color=color.black, z=-2)
sat_slider.on_click = def():
    sat_slider.indicator.x = mouse.point[0]

    _curr_color = rgb_to_hsv(current_color)
    value = (mouse.point[0]+.5)
    color_as_rgb = hsv(_curr_color[0], value, _curr_color[2])

    current_color[0] = color_as_rgb[0]
    current_color[1] = color_as_rgb[1]
    current_color[2] = color_as_rgb[2]
    set_color(current_color, False)
sat_slider.while_dragging = sat_slider.on_click
    # print('set sat:', value, current_color)
val_slider = Entity(*slider_style, parent=color_menu.menu, y=-slider_height*1.1)
val_slider.overlay = Entity(parent=val_slider, texture='horizontal_gradient.png', color=color.black, rotation=180, y=0, z=-1, roundness=.15)
val_slider.indicator = Entity(parent=val_slider, scale_x=.01, color=color.black, z=-2)
val_slider.on_click = def():
    val_slider.indicator.x = mouse.point[0]

    color_as_hsv = rgb_to_hsv(current_color)
    value = (mouse.point[0]+.5)
    color_as_rgb = hsv(color_as_hsv[0], color_as_hsv[1], value)
    current_color[0] = color_as_rgb[0]
    current_color[1] = color_as_rgb[1]
    current_color[2] = color_as_rgb[2]
    set_color(current_color, False)
    # print('set value:', value)
val_slider.while_dragging = val_slider.on_click

def set_color(value, move_sliders=True):
    current_color = value
    color_preview.color = rgb(current_color[0]/255, current_color[1]/255, current_color[2]/255)
    color_as_hsv = rgb_to_hsv(current_color)
    color_saturated = hsv(color_as_hsv[0], 1, color_as_hsv[2])
    color_desaturated = hsv(color_as_hsv[0], 0, color_as_hsv[2])
    # print(rgb(val[0]/255, val[1]/255, val[2]/255))
    sat_slider.color = rgb(color_saturated[0]/255, color_saturated[1]/255, color_saturated[2]/255)
    # sat.overlay.color = rgb(color_desaturated[0]/255, color_desaturated[1]/255, color_desaturated[2]/255)
    # sat.overlay.alpha = current_color[3]/255
    if move_sliders:
        print('aaaaa', current_color)
        hue_slider.indicator.x = -.5 + color_as_hsv[0]/360
        sat_slider.indicator.x = -.5 + color_as_hsv[1]
        val_slider.indicator.x = -.5 + color_as_hsv[2]

menu_parent = Entity(parent=camera.ui, visible_self=False, name='menu_parent')
# Entity(parent=menu_parent, origin=[-.5,0], color=hsv(0,0,.1), x=(.5*aspect_ratio)-.125)
# Entity(parent=menu_parent, origin=[0, .5], color=hsv(0,0,.1), y=-.5+.1, scale_x=2)

compiler.define(*button_style, parent=menu_parent, roundness=.01, origin=[.5,.5], text_origin=[0,0], x=(.5*aspect_ratio)-.0125, scale=[.05,.05], z=-1, text_size=1.5, color=hsv(0,0,.05), text_color=hsv(0,.0,.8))
right_button_x = (.5*aspect_ratio)-.0125
left_button_x = right_button_x-.05

increase_brush_size_button = Entity(*button_style, y=.1, text='+', on_click=def():brush_size = [e*1.5 for e in brush_size])
decrease_brush_size_button = Entity(*button_style, y=.1, x=left_button_x, text='-', on_click=def():brush_size = [e*1/1.5 for e in brush_size])


for i, e in enumerate(brushes):
    let brush = e
    let brush_button = Entity(*button_style, xy=[right_button_x,.05*-i])
    icon = Entity(roundness=.01, parent=brush_button, texture=e.textures[0], xy=[-.5,-.5], color=color.black, z=-1, scale=.7)
    icon_aspect = brush.size[0] / brush.size[1]
    if icon_aspect > 1:
        icon.scale = [1, icon_aspect]
    else:
        icon.scale = [icon_aspect, 1]

    brush_button.on_click = def():
        set_brush(brush)

# //     if key == 'i':
# //         change_to_poke_brush()

window.onfocus = def():
    using_eyedropper = False


save_button = Button(*button_style, y=-.25, scale=[.1,.04], text='save')
save_button.on_click = def save():
    dataURL = canvas.toDataURL("image")
    window.localStorage.setItem("image", dataURL)
save_button.input = def input(key):
    if key == 's':
        save_button.on_click()


saved_image = window.localStorage.getItem("image")
if saved_image:
    load_image_to_canvas(saved_image)

def load_image_to_canvas(image):
    var loaded_image = new Image
    loaded_image.src = image
    loaded_image.onload = def on_load():
        ctx.drawImage(loaded_image, 0, 0)


async def paste(e):
    e.preventDefault()
    e.stopPropagation()
    let file = e.clipboardData.items[0].getAsFile()
    if file.name == 'image.png':
        var URLObj = window.URL || window.webkitURL;
        var source = URLObj.createObjectURL(file);
        print('-----', source)
        var pastedImage = new Image();
        pastedImage.src = source
        ctx.drawImage(pastedImage, 0, 0)
        invoke(def anon():
            ctx.drawImage(pastedImage, 0, 0)
        , delay=.1)

window.addEventListener("paste", paste)


download_button = Button(*button_style, text='download', scale=[.1,.04], origin=[.5,.5], x=(.5*aspect_ratio)-.0125, y=-.2)
var link = document.createElement('a');
download_button.on_click = def download():
    link.download = "untitled.png"
    # download_button.href = canvas.toDataURL()
    link.href = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream")
    #
    link.click()
    print('download')

#
const undo_data = [canvas.toDataURL("image"), ]
undo_index = 0

def undo():
    if undo_index > 0:
        undo_index -= 1

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def on_load():
        ctx.drawImage(loaded_image, 0, 0)

def redo()
    if undo_index < undo_data.length:
        undo_index += 1

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def():
        ctx.drawImage(loaded_image, 0, 0)


def record_undo():
    if undo_data.length > undo_index+1:
        undo_data.splice(undo_index+1)
        # print('delete old undo data')

    undo_data.push(canvas.toDataURL())
    # print('record undo')
    undo_index += 1

using_lasso_tool = False
selection = {'points':[]}
lasso_tool = Entity(visible_self=False)
lasso_tool.input = def input(key):
    if key == 'l':
        using_lasso_tool = True
    # elif key == 'l up':
    #     using_lasso_tool = False
    if using_lasso_tool and key == 'left mouse down':
        pos = mouse.point
        var x = int((pos[0]+.5) * w)
        var y = int((pos[1]-.5) * -h)
        lasso_prev_pos = [x,y]
        if not held_keys['shift']:
            selection.points = []
        lasso_tool.start_point = [x,y]


    if using_lasso_tool and key == 'left mouse up':
        print('END SELECTION')
        start = lasso_tool.start_point
        end = selection.points[len(selection.points)-1]
        dist = distanceApprox(start, end)
        if not dist:
            return

        for i in range(0, dist):
            t = i / dist
            let _x = int(lerp(start[0], end[0], t))
            let _y = int(lerp(start[1], end[1], t))
            if not [_x,_y] in selection.points:
                selection.points.append([_x,_y])
                ctx.fillStyle = rgb(0/255, 0/255, 0/255, 255/255)
                ctx.fillRect(_x, _y, 1, 1);

        unique_selection = []

        for a in selection.points:
            is_duplicate = False
            # if a in unique_selection: contine
            for b in unique_selection:
                if a[0]===b[0] and a[1]===b[1]:
                    is_duplicate = True
                    break

            if is_duplicate:
                continue

            unique_selection.append(a)
        selection.points = unique_selection

        xs = [e[0] for e in selection.points]
        ys = [e[1] for e in selection.points]

        selection.min_x = min(...xs)
        selection.max_x = max(...xs)
        selection.min_y = min(...ys)
        selection.max_y = max(...ys)

        selection.width = (selection.max_x - selection.min_x) +1
        selection.height = (selection.max_y - selection.min_y) +1

        def inside(point, vs):
            # // ray-casting algorithm based on
            # // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html

            var x = point[0], y = point[1]

            var inside = False
            for (var i=0, j=vs.length-1; i < vs.length; j=i++):
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];

                intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
                if intersect:
                    inside = !inside;

            return inside

        poly = selection.points
        for y in range(selection.min_y, selection.min_y+selection.height):
            for x in range(selection.min_x, selection.min_x+selection.width):
                if inside([x,y], poly):
                    ctx.fillRect(x, y, 1, 1);

            length = points_on_this_y[-1] - points_on_this_y[0]

        lasso_prev_pos = None


# def floodfill(matrix, x, y, first=True):
#     if matrix[y][y] == 1:
#         return
#
#     if first:
#         fill_target = matrix[x][y]
#
#     if matrix[x][y] == fill_target:
#         matrix[x][y] = 1
#         # recursively invoke flood fill on all surrounding cells
#         if x > 0:
#             self.floodfill(matrix, x-1, y, False)
#         if x < selection.width-1:
#             self.floodfill(matrix, x+1, y, False)
#         if y > 0:
#             self.floodfill(matrix, x, y-1, False)
#         if y < selection.height-1:
#             self.floodfill(matrix, x, y+1, False)


lasso_prev_pos = None

lasso_tool.update = def():
    if not using_lasso_tool or not mouse.left:
        return
    pos = mouse.point
    var x = int((pos[0]+.5) * w)
    var y = int((pos[1]-.5) * -h)

    dist = distanceApprox(lasso_prev_pos, [x,y])
    # dist = abs(y - lasso_prev_pos[1])
    if not dist:
        return

    for i in range(0, dist):
        t = i / dist
        let _x = int(lerp(lasso_prev_pos[0], x, t))
        let _y = int(lerp(lasso_prev_pos[1], y, t))
        if not [_x,_y] in selection.points:
            selection.points.append([_x,_y])
            ctx.fillStyle = rgb(0/255, 0/255, 0/255, 255/255)
            ctx.fillRect(_x, _y, 1, 1);

    lasso_prev_pos = [x,y]
    # if not [x,y] in selection:
    #     selection.append([x,y])
    #     ctx.fillStyle = rgb(0/255, 0/255, 0/255, 255/255)
    #     ctx.fillRect(x, y, 2, 2);

</script>
<script src="../sunsnake_compiler.js"></script>
</html>
