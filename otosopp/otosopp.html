<html><title>otosopp</title><body>
<script src="color_conversion.js"></script>
<script src="../taptapir/taptapir.js"></script>
<script src="../taptapir/taptapir_gamepad.js"></script>
<script src="assets/base_64_brushes.js"></script>
<script type='text/sunsnake'>

set_window_color('#222')
set_background_color('#111')
set_orientation('horizontal')
set_scale(1)
# set_scale(.5)
canvas_scale = .8
document.addEventListener('contextmenu', event => event.preventDefault());


bg = Entity(visible_self=False, scale=[2*canvas_scale, 2*canvas_scale], draggable=True, lock_x=True, lock_y=True, ignore_collision=False)

right_menu_bg = Entity(origin=[.5,0], scale=[.115,1], position=right, color=hsv(0,0,.07), alpha=.9, ignore_collision=False)
menu_parent = Entity(parent=camera.ui, visible_self=False)
right_button_x = (.5*aspect_ratio)-.005
left_button_x = right_button_x-.055
sunsnake.define(*Button(,Entity(parent=menu_parent, roundness=.01, origin=[.5,.5], text_origin=[0,0], x=(.5*aspect_ratio)-.01, scale=[.05,.05], z=-1, text_size=1.5, color=hsv(0,0,.03), text_color=hsv(0,.0,.8),)


new_canvas_handler = Entity(visible_self=False)
new_canvas_prompt = Entity(scale=[.25,.125], enabled=False, roundness=.05, shadow=True, parent=camera.ui, color=color.black, text_origin=[0,.5], text=' New Canvas', text_color=color.light_gray, text_size=2, ignore_collision=False)
Entity(parent=new_canvas_prompt, text='x', scale=.1, color=new_canvas_prompt.color, text_color=new_canvas_prompt.text_color, text_origin=[0,0], text_size=2)
new_canvas_prompt.close_button = Entity(parent=new_canvas_prompt, text='x', scale=.2, color=color.red, text_color=color.white, text_origin=[0,0], text_size=2, roundness=.5, xy=[.6,.5], origin=[.5,0], on_click=def():new_canvas_prompt.enabled=False)
w_field = InputField(parent=new_canvas_prompt, scale=(1,.3), origin=[.5,0], x=-.05, value=512)
h_field = InputField(parent=new_canvas_prompt, scale=(1,.3), origin=[-.5,0], x=.05, value=512)
create_button = Button(parent=new_canvas_prompt, color=color.azure, origin=[0,-.5], scale=[.4,.25], roundness=.5, y=-.5, text='Create', text_size=2, text_color=color.light_gray, on_click=def():new_document(w_field.value,h_field.value); new_canvas_prompt.enabled=False)
create_button.input = def input(key):
    if held_keys['control'] and key == 'enter':
        create_button.on_click()
canvas_sizes = [[512,512], [1024,1024], [2048,2048], [1920,1080], [1920*2,1080*2], [2048,1024]]
for i, size in canvas_sizes:
    let b = *Button(parent=new_canvas_prompt, scale=[.3,1/len(canvas_sizes)], origin=[0,.5], x=-.68, y=.5-(1/len(canvas_sizes)*i), text=`${size}`, text_size=1.25, color=hsv(0,0,0), text_color=color.light_gray, roundness=.5)
    b.on_click = def():
        w_field.value = size[0]
        h_field.value = size[1]


new_canvas_handler.input = def input(key):
    if held_keys['control'] and held_keys['alt'] and key == 'n':
        new_canvas_prompt.enabled = True
    if key == 'escape':
        new_canvas_prompt.enabled = False


resolution_info = *Button(origin=[-.5,-.5], position=bottom_left, scale=[.075,.015], text='??? x ???', roundness=0, alpha=.5, text_size=1)
new_file_button = *Button(position=top_left, origin=[-.5,.5], text='+', scale=[.05,.025], on_click=def():new_canvas_prompt.enabled=True)
info_button = *Button(xy=[(-.5*aspect_ratio)+.125,.5], origin=[-.5,.5], text='â“˜', scale=[.025,.025], ignore_collision=False)
info_button.el.onmouseenter = def():
    info_window.enabled = True
info_button.el.onmouseleave = def():
    info_window.enabled = False

info_text = `Shortcuts:
[b] brush
[x] smaller brush
[s] bigger brush
[e] erase
[l] lasso select tool
[m] rect select tool
[ctrl+z] undo
[ctrl+y] redo
[alt] sample color
[ctrl+alt] sample current layer
[a] / [right click] radial menu
`
info_window = Text(parent=info_button.parent, text=info_text, text_size=1.5, text_color=color.light_gray, color=color.black, alpha=.9, roundness=.005, enabled=False)
info_window.fit_to_text()
info_window.origin=[-.5,.5]
info_window.xy = [info_button.x, info_button.y-info_button.scale_y]
info_window.el.style.fontFamily = 'monospace'

canvas_entity = Entity(parent=bg, color='#606060', scale=[1/2,1/2], z=-1)
canvas_entity.el.style.overflow = 'hidden'
shadow_entity = Entity(parent=bg, scale=canvas_entity.scale, shadow='0px 0px 100px #0008', visible_self=False)


layer_menu = *Button(scale=[.105,.4], origin=[0,-.5], x=((.5*aspect_ratio)-.0125)-.045, y=-.39, visible_self=True, roundness=.005, color=hsv(0,0,.03), ignore_collision=False)

background_color_menu = Entity(parent=layer_menu.parent, x=layer_menu.x, origin=layer_menu.origin, y=layer_menu.y-.0125, visible_self=False, scale=[layer_menu.scale_x*.95, .010], z=1, alpha=.4)
for i, col in ['#000000', '#404040', '#606060', '#bfbfbf', '#ffffff']:
    let change_bg_color_button = *Button(parent=background_color_menu, x=-.5+(i/5), color=col, origin=[-.5,-.5], scale=[1/6,1], roundness=.25, on_click=def():canvas_entity.color=col)

add_layer_button = *Button(text='+', scale=[layer_menu.scale_x/2,.03], roundness=.005, origin=[.5,-.5], x=layer_menu.x, y=layer_menu.y-.05, on_click=add_layer)
delete_layer_button = *Button(text='-', scale=[layer_menu.scale_x/2,.03], roundness=.005, origin=[.5,-.5], x=layer_menu.x+layer_menu.scale_x/2, y=layer_menu.y-.05, on_click=delete_layer)

def add_layer(name='layer', _w=w, _h=h, enabled=True, select=True):
    if name == 'layer':
        name = `layer ${len(layers)}`
    let layer = Entity(name=name, parent=canvas_entity, color=color.clear, z=-1, enabled=enabled)
    layers.append(layer)

    layer.canvas = document.createElement('canvas');
    layer.canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
    layer.canvas.width = _w
    layer.canvas.height = _h
    layer.model.appendChild(layer.canvas)

    layer.ctx = layer.canvas.getContext('2d', {willReadFrequently: true})

    # print('--------------------hidden:', not enabled)
    if not enabled:
        return layer

    layer.layer_button = Button(enabled=enabled, x=layer_menu.x, origin=[0,-.5], scale=[.105,.03], roundness=.1, y=layer_menu.y+((len(layers)-1)*1.01*.03), text_size=1, text=name, text_color=color.light_gray,
        draggable=True, lock_x=True, min_y=layer_menu.y-.015, max_y=layer_menu.y+layer_menu.scale_y+.015, color=hsv(0,0,.1), layer=layer)
    layer.layer_button.original_color = layer.layer_button.color
    layer.layer_button.on_click = def():
        set_layer(layer)
    layer.layer_button.drop = def():
        layer_buttons = [l.layer_button for l in layers]
        def sort_by_y(first, second):
            return first.y - second.y

        layer_buttons.sort(sort_by_y)
        for i, lb in layer_buttons:
            lb.y = layer_menu.y+((i)*1.01*.03)

        layers = [lb.layer for lb in layer_buttons]
        set_layer(layer)


    layer.opacity_slider = RainbowSlider(parent=layer.layer_button, scale=[1,.2], x=.0, y=.125, z=-2, show_lines=True, max=20, color=color.red, default=20, gradient=[hsv(210,.5,.6,), ], alpha=.75)
    # layer.opacity_slider.bar.alpha = .25
    layer.opacity_slider.on_value_changed = def():
        layer.canvas.style.opacity = layer.opacity_slider.value/layer.opacity_slider.max

    let toggle_layer_visibility_button = Button(parent=layer.layer_button, origin=[-.5,-.5], x=-.48, y=.3, scale=[.2,.6], roundness=.1, alpha=.25, text_size=2, z=-1, color=color.black, text='', text_color=color.white)
    toggle_layer_visibility_button.on_click = def():
        layer.enabled = not layer.enabled
        text = ' '
        if not layer.enabled:
            text = 'H'
        toggle_layer_visibility_button.text = text

    if select:
        set_layer(layer)

    return layer

def delete_layer(layer=current_layer):
    if len(layers) == 0:
        return

    current_layer


w = 1920
h = 1080
layers = []
def new_document(_w, _h, fill_color=color.clear):

    for e in layers:
        destroy(e)
    layers = []

    w = _w
    h = _h
    canvas_aspect = w/h
    print('new_document', canvas_aspect)
    bg.scale = [2*canvas_scale*canvas_aspect, 2*canvas_scale]
    selection_canvas.width = w
    selection_canvas.height = h

    first_layer = add_layer()
    if fill_color == color.clear:
        first_layer.ctx.clearRect(0, 0, w, h)
    else:
        first_layer.ctx.fillStyle = rgb(...fill_color)
        first_layer.ctx.fillRect(0, 0, w, h)

    current_layer = first_layer
    undo_data = [current_layer.canvas.toDataURL("image"), ]
    undo_index = 0

    resolution_info.text = `${w} x ${h}`


def set_layer(layer):
    current_layer = layer
    print('current_layer:', current_layer)
    for i, layer in layers:
        layer.layer_button.color = layer.layer_button.original_color
        layer.layer_button.text_color = hsv(0,0,.4)
        layer.z = -i
    # current_layer.layer_button.color = '#333a8b'
    current_layer.layer_button.color = hsv(0,0,.8)
    current_layer.layer_button.text_color = hsv(0,0,.2)


selection_canvas = document.createElement('canvas')
selection_canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
selection_canvas.willReadFrequently = True

selection_canvas_entity = Entity(name='selection_canvas', parent=bg, color=color.clear, scale=[1/2,1/2], z=-1)
selection_canvas_entity.model.appendChild(selection_canvas)

selection_ctx = selection_canvas.getContext('2d', {willReadFrequently: true})
selection_ctx.fillStyle = rgb(128/255, 0/255, 0/255, 255/255)
selection_ctx.clearRect(0, 0, w, h)


square_brush = {'textures':None, 'shape':'rect', 'size':[50, 50], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'pressure_stremin_pressurength':1}
round_brush = {'textures':None, 'shape':'circle', 'size':[1, 1], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':1}
round_bitmap_brush = {'textures':["round_brush_16.png", ], 'size':[2, 2], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':0}
poke_brush = {'textures':["pokebrush.png", ], 'size':[64, 64], 'spacing':.075, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':0}
poke_brush_small = {'textures':["pokebrush.png", ], 'size':[16, 16], 'spacing':.075, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':1}
poke_brush_scatter = {'textures':["pokebrush.png", 'pokebrush.png'], 'size':[256, 256], 'spacing':.25, 'painterly_brush':False, 'rotate':'random', 'draw_on_click':False, 'min_pressure':1}
painterly_brush = {'textures':["RGBA anim 01.png", "RGBA anim 02.png", "RGBA anim 03.png", "RGBA anim 04.png", ], 'size':[178, 400], 'spacing':.5, 'painterly_brush':True, 'rotate':True, 'draw_on_click':False, 'min_pressure':1}

brushes = [round_brush, square_brush, round_bitmap_brush, poke_brush, poke_brush_small, painterly_brush, poke_brush_scatter, poke_brush_scatter, poke_brush_scatter, poke_brush_scatter]
current_brush = None
brush_canvases = []
increase_brush_size_button = *Button(x=right_button_x, y=.36, text='+')
increase_brush_size_button.on_click = def():
    new_brush_size = [e*1.5 for e in brush_size]
    set_brush_size(new_brush_size)
decrease_brush_size_button = *Button(y=.36, x=left_button_x, text='-')
decrease_brush_size_button.on_click = def():
    new_brush_size = [e*1/1.5 for e in brush_size]
    set_brush_size(new_brush_size)
brush_size_label = *Button(text='??', y=increase_brush_size_button.y+(increase_brush_size_button.scale_y*.55), x=lerp(increase_brush_size_button.x, decrease_brush_size_button.x, .5), scale_y=.025)

def set_brush(brush):
    current_brush = brush

    brush_tips = None
    if brush.textures:
        for e in brush_canvases:
            e.remove()

        brush_tips = [new Image() for e in brush.textures]
        brush_canvases = [document.createElement('canvas') for e in brush_tips]
        for i in range(brush_tips.length):
            # brush_tips[i].src = brush.textures[i]
            brush_tips[i].src = brush_textures[brush.textures[i]]
        # brush_cursor.texture = brush_tips[i].src

    print('set brush', brush)
    set_brush_size(brush.size)
    SPACING = brush.spacing
    using_painterly_brush = brush.painterly_brush
    rotate_brush = brush.rotate
    draw_on_click = brush.draw_on_click

brush_size = [64,64]
brush_cursor = Entity(parent=bg, color=color.clear, scale=.1, z=-10)
brush_cursor.model.style.borderWidth = '1px'
brush_cursor.model.style.borderColor = '#cccccc33'
brush_cursor.model.style.borderStyle = 'solid'
brush_cursor.model.style.borderRadius = '50%'
brush_cursor.update = def brush_cursor_update():
    if mouse.hovered_entity == bg and mouse.point:
        brush_cursor.xy = mouse.point


def set_brush_size(value):
    brush_size = value
    brush_size_label.text = `${brush_size[0]}`
    brush_cursor.scale_x = brush_size[0] / w * canvas_entity.scale_x
    brush_cursor.scale_y = brush_size[1] / h * canvas_entity.scale_y


brush_distance = 0
draw_on_click = False
rotate_brush = True
using_painterly_brush = True
prev_brush_tip = -1
set_brush(poke_brush)
# set_brush(round_brush)
# set_brush_size([64,64])
IMG = new Image()
current_color = [32, 32, 32, 255]
drawing = False
smoothing = False
prev_pos = None
start_position = None
snap_to_hex = False
tool = 'brush'
ERASING = False
SMUDGE = False
SMUDGE_STRENGTH = 1
# cursor = Entity(scale=.02, color=color.red, alpha=.1, parent=canvas_entity, enabled=False)

brush_tool = Entity(name='brush_tool', visible_self=False)
brush_tool.on_disable = def():
    brush_cursor.enabled = False
    mouse.visible = True
brush_tool.on_enable = def():
    brush_cursor.enabled = True
    mouse.visible = False

# temp_layer_entity = Entity(parent=canvas_entity, color=color.clear, z=-100, enabled=True)
temp_canvas = document.createElement('canvas')
temp_canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
temp_canvas.width = w
temp_canvas.height = h
# temp_layer_entity.model.appendChild(temp_canvas)
temp_ctx = temp_canvas.getContext('2d', {willReadFrequently: true})

def update_brush_tip():
    if not using_painterly_brush: # tint the temporary brush tip
        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            brush = brush_tips[j]

            print(brush_size[0], mouse.pressure, int(max(brush_size[0] * mouse.pressure, 10)))
            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            if mouse.pressure < 1:
                brush_canvas.width *= mouse.pressure
                brush_canvas.height *= mouse.pressure
            brush_canvas_context = brush_canvas.getContext("2d", {willReadFrequently: true})
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            if not SMUDGE:
                img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

                for i in range(0, img_data.data.length, 4):
                    img_data.data[i] = img_data.data[i] * (current_color[0]/255)
                    img_data.data[i+1] = img_data.data[i+1] * (current_color[1]/255)
                    img_data.data[i+2] = img_data.data[i+2] * (current_color[2]/255)
                    img_data.data[i+3] = img_data.data[i+3] * (current_color[3]/255)

            elif SMUDGE:
            #     print('SMUDGE')
            #     # sample the canvas for colors and multiply with brush alpha
                pos = get_canvas_position()
                img_data = current_layer.ctx.getImageData(pos[0]-(brush_size[0]/2), pos[1]-brush_size[1]/2, brush_size[0], brush_size[1])
                brush_pixels = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

                for i in range(0, img_data.data.length, 4):
                    img_data.data[i+3] = img_data.data[i+3] * brush_pixels.data[i+3] * (1/255*SMUDGE_STRENGTH)
                    # img_data.data[i+3] = img_data.data[i+3]
            #     # brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            #     # img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])
            #     # self.smudge_IMG = self.parent.current_layer.img_data.crop((
            #     #         stamp_pos[0], stamp_pos[1],
            #     #         stamp_pos[0]+self.brush.width, stamp_pos[1]+self.brush.height))
            #     #
            #     #     try:
            #     #         self.smudge_IMG.putalpha(self.brush.split()[-1])
            #     #     except:
            #     #         pass

            brush_canvas_context.putImageData(img_data, 0, 0)
    else: # special tint for paiterly brushes to keep contrast
        color_as_hsv = rgb_to_hsv(current_color)
        c = color_as_hsv[2] * 255
        c = (current_color[0] + current_color[1] + current_color[2])/3
        # print('------------', c)
        sat = color_as_hsv[1]
        contrast = 64
        dark = c-contrast
        light = c+contrast
        # adjust contrast and brighten based on saturation
        dark = c-contrast + (sat*contrast*1.2)
        light = c+contrast + contrast + (sat*contrast*1.2)

        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            brush = brush_tips[j]

            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            brush_canvas_context = brush_canvas.getContext("2d", {willReadFrequently: true})
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

            for i in range(0, img_data.data.length, 4):
                # img_data.data[i] = lerp(dark, light, img_data.data[i]/255) * lerp(1, current_color[0]/255, sat)
                # img_data.data[i+1] = lerp(dark, light, img_data.data[i+1]/255) * lerp(1, current_color[1]/255, sat)
                # img_data.data[i+2] = lerp(dark, light, img_data.data[i+2]/255) * lerp(1, current_color[2]/255, sat)
                img_data.data[i] = lerp(dark, light, img_data.data[i]/255) * current_color[0]/255
                img_data.data[i+1] = lerp(dark, light, img_data.data[i+1]/255) * current_color[1]/255
                img_data.data[i+2] = lerp(dark, light, img_data.data[i+2]/255) * current_color[2]/255
                img_data.data[i+3] = img_data.data[i+3] * current_color[3]/255

            brush_canvas_context.putImageData(img_data, 0, 0)



brush_tool.input = def brush_tool_input(key):
    if mouse.hovered_entity == bg and key == 'left mouse down':
        if not held_keys['control']:
            prev_pos = None

        drawing = True
        # print('start drawing')
        # temp_ctx.clearRect(0, 0, w, h)
        # current_layer.ctx.putImageData(img_data, x-(brush_size[0]/2), y-(brush_size[1]/2))

        if tool == 'eyedropper' or not brush_tips:
            paint()
            return


        if tool == 'eyedropper':
            drawing = True

        update_brush_tip()

        try:
            paint()
        catch:
            return

    if drawing and key == 'left mouse up':
        drawing = False
        # print('stop drawing')
        # img_data = temp_ctx.getImageData(0, 0, w, h)
        # current_layer.ctx.putImageData(img_data, 0, 0)
        # current_layer.ctx.drawImage(temp_canvas)
        # temp_ctx.clearRect(0, 0, w, h)
        record_undo()

brush_tool.update = def brush_tool_update():
    if drawing:

        paint()


def get_canvas_position(layer=current_layer):
    if not mouse.point:
        return [0,0]

    pos = mouse.point
    return [int((((pos[0]-(layer.x*.5))*2)+.5) * w), int((((pos[1]-(layer.y*.5))*2)-.5) * -h)]
    # return [int((((pos[0])*2)+.5) * w), int((((pos[1])*2)-.5) * -h)]


def draw_circle(x, y):
    current_layer.ctx.globalAlpha = current_color[3]/255
    current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
    if ERASING:
        current_layer.ctx.globalAlpha = 0
        # current_layer.ctx.fillStyle = `rgba(256, 256, 256, 64)`
        print('aaa')


    if not selection.active:
        # current_layer.ctx.fillRect(x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
        current_layer.ctx.beginPath()
        current_layer.ctx.arc(x, y, brush_size[0], 0, 2*Math.PI)
        current_layer.ctx.fill()
        current_layer.ctx.closePath()
        print('fill')
        return

    brush_half_w = brush_size[0] / 2
    brush_half_h = brush_size[1] / 2

    for _y in range(clamp(y-brush_half_h, 0, h-1), clamp(y+brush_half_h, 0, h-1)):
        for _x in range(clamp(x-brush_half_w, 0, w-1), clamp(x+brush_half_w, 0, w-1)):
            if selection.active and selection.matrix[int(_x)][int(_y)]:
                current_layer.ctx.fillRect(int(_x), int(_y), 1, 1);

def draw_rect(x, y):
    current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
    if not selection.active:
        current_layer.ctx.fillRect(int(x-(brush_size[0]/2)), int(y-(brush_size[1]/2)), brush_size[0], brush_size[1])
        return

    brush_half_w = brush_size[0] / 2
    brush_half_h = brush_size[1] / 2

    for _y in range(clamp(y-brush_half_h, 0, h-1), int(clamp(y+brush_half_h, 0, h-1))):
        for _x in range(clamp(x-brush_half_w, 0, w-1), int(clamp(x+brush_half_w, 0, w-1))):
            if selection.active and selection.matrix[int(_x)][int(_y)]:
                current_layer.ctx.fillRect(int(_x), int(_y), 1, 1);

var a = 0

def lerp(a, b, t):
    return ((1-t)*a) + (t*b)


def draw_brush_image(brush_canvas, x, y):
    img_data = current_layer.ctx.getImageData(x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
    brush_data = brush_canvas.getContext("2d", {willReadFrequently: true}).getImageData(0, 0, brush_size[0], brush_size[1])

    if not ERASING:
        temp_canvas.width = brush_data.width
        temp_canvas.height = brush_data.height
        temp_ctx.putImageData(brush_data, 0, 0)
        current_layer.ctx.drawImage(temp_canvas, x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])

    else:
        for (i=3; i<len(img_data.data); i+=4):
            img_data.data[i] -= brush_data.data[i] / 2.2

        current_layer.ctx.putImageData(img_data, x-(brush_size[0]/2), y-(brush_size[1]/2))


def paint():
    if not current_layer or not current_layer.enabled:
        return

    if held_keys['alt'] and held_keys['control']: # sample current layer
        pos = get_canvas_position()
        sampled_color = current_layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
        for i in range(3):
            sampled_color[i] = lerp(canvas_entity.color[i], sampled_color[i], sampled_color[3]/255)

        sampled_color[3] = 255
        set_color(sampled_color)
        return

    # sample combined
    if (held_keys['alt'] and not held_keys['control']) or held_keys['h']:
        # sampled_colors = []
        # canv_col = canvas_entity.color
        combined_sample = canvas_entity.color
        for layer in layers:
            pos = get_canvas_position(layer)
            sampled_color = layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
            # sampled_colors.append(sampled_color)
            for i in range(3):
                combined_sample[i] = lerp(combined_sample[i], sampled_color[i], sampled_color[3]/255)

        combined_sample[3] = 255
        # alphas = [e[3] for e in sampled_colors]
        # alpha = min(sum(alphas), 255)
        # combined_color = [lerp(canvas_entity.color[i], combined_color[i], alpha/255) for i in range(3)]
        set_color(combined_sample)

        return

    if mouse.hovered_entity != bg:
        return

    if held_keys['space']:
        return



    [x, y] = get_canvas_position()
    if current_brush['min_pressure'] < 1:
        update_brush_tip()

    if held_keys['w'] and prev_pos:
        x = lerp(prev_pos[0], x, .025)
        y = lerp(prev_pos[1], y, .025)

    if prev_pos == None:
        if draw_on_click:
            if brush_tips:
                prev_brush_tip += 1
                if prev_brush_tip >= brush_tips.length:
                    prev_brush_tip = 0

                    draw_brush_image(brush_canvases[prev_brush_tip], x, y)

            elif current_brush.shape == 'rect':
                draw_rect(x, y)

            elif current_brush.shape == 'circle':
                draw_circle(x, y)


        start_position = [x,y]
        prev_draw_pos = pos
        prev_pos = [x,y]
        pixels_traveled = 0
        return

    if snap_to_hex:
        y = start_position[1] + (x-start_position[0])

    if held_keys['shift']:
        velocity = [x-start_position[0], y-start_position[1]]
        if abs(velocity[0]) > abs(velocity[1]):
            y = prev_pos[1]
        else:
            x = prev_pos[0]

    distance_since_last_frame = distanceApprox(prev_pos, [x,y])
    pixels_traveled += distance_since_last_frame
    spacing_in_pixels = brush_size[1]*SPACING
    steps = floor(pixels_traveled / spacing_in_pixels)

    delta_pos = [x - prev_pos[0], y - prev_pos[1]]
    radians = -math.atan2(delta_pos[0], delta_pos[1])

    for i in range(0, steps):
        if brush_tips:
            prev_brush_tip += 1
            if prev_brush_tip >= brush_tips.length:
                prev_brush_tip = 0

        t = i / steps
        let _x = lerp(prev_pos[0], x, t)
        let _y = lerp(prev_pos[1], y, t)



        if not rotate_brush:
            if brush_tips:
                draw_brush_image(brush_canvases[prev_brush_tip], _x, _y)
            elif current_brush.shape == 'rect':
                draw_rect(_x, _y)
            elif current_brush.shape == 'circle':
                draw_circle(_x, _y)

        elif rotate_brush == True:
            if brush_tips:
                IMG.src = brush_canvases[prev_brush_tip].toDataURL()
            invoke(def anon():
                current_layer.ctx.translate(_x, _y)
                current_layer.ctx.rotate(radians)
                current_layer.ctx.drawImage(IMG, -brush_size[0]/2, -brush_size[1]/2)
                current_layer.ctx.rotate(-radians)
                current_layer.ctx.translate(-_x, -_y)
            , delay=0)
        elif rotate_brush == 'random':
            if brush_tips:
                IMG.src = brush_canvases[prev_brush_tip].toDataURL()
            invoke(def anon():
                random_radian = random_int(0, 360) * Math.PI / 180
                current_layer.ctx.translate(_x, _y)
                current_layer.ctx.rotate(random_radian)
                current_layer.ctx.drawImage(IMG, -brush_size[0]/2, -brush_size[1]/2)
                current_layer.ctx.rotate(-random_radian)
                current_layer.ctx.translate(-_x, -_y)
            , delay=0)

        prev_draw_pos = [_x, _y]

    pixels_traveled -= steps * spacing_in_pixels
    prev_pos = [x, y]
    # prev_pos_for_line_draw_mode = [x, y]
    # if not held_keys['shift']:


# Approximation by using octagons approach
def distanceApprox(p1,p2):
    var x = p2[0]-p1[0]
    var y = p2[1]-p1[1]
    return 1.426776695*Math.min(0.7071067812*(Math.abs(x)+Math.abs(y)), Math.max(Math.abs(x), Math.abs(y)))

opacity_keys = '|1234567890'.split('')
target_zoom = bg.scale_y
zoom_label = *Button(text='100%', scale=[.1,.025], origin=[.5,-.5], y=-.495, text_color=hsv(0,0,.5), text_size=1.5, on_click=def():target_zoom=1, x=lerp(left_button_x, right_button_x, .5))
zoom_label.update = def zoom_label_update():
    bg.scale_x = lerp(bg.scale[0], target_zoom*canvas_aspect, .2)
    bg.scale_y = lerp(bg.scale[1], target_zoom, .2)

def input(key):
    # print(key)
    for i, e in enumerate(opacity_keys):
        if key == e:
            if current_tool == brush_tool:
                if not SMUDGE:
                    current_color[3] = int(255/10 * i)
                    # print(current_color)
                else:
                    SMUDGE_STRENGTH = int(i) / 10
                    print(SMUDGE_STRENGTH)
    if (held_keys['control'] and key == 'z'):
        undo()

    # if held_keys['control'] and key == 'y':
    if key == 'y':
        redo()

    # if key == 'a':
    #     for y in range(h/2):
    #         for x in range(w/2):
    #             selection['matrix'][x][y] = True
    #     render_selection()

    if held_keys['control'] and key == 'c':
        copied_image_data = copy_selection()
        # data = Uint8ClampedArray.from(image_data.data)
        data = Uint8ClampedArray.from(copied_image_data.data)
        navigator.clipboard.writeText(`local_image:${JSON.stringify([data, selection.bounds[0], selection.bounds[1], selection.bounds[2]-selection.bounds[0], selection.bounds[3]-selection.bounds[1]])}`)



    if key in ['i','s','gamepad y']:
        new_size = [clamp(int(e*2), 1, 2048) for e in brush_size]
        set_brush_size(new_size)

    if key in ['j','x','gamepad x']:
        new_size = [clamp(int(e/2), 1, 2048) for e in brush_size]
        set_brush_size(new_size)

    # if key == 'h':
    #     selection_canvas_entity.enabled = not selection_canvas_entity.enabled
        # snap_to_hex = True
    if key == 'scroll down' or (held_keys['control'] and key == 'down arrow'):
        target_zoom = target_zoom*.9
        zoom_label.text = `${int(target_zoom*100)}%`
    if key == 'scroll up' or (held_keys['control'] and key == 'up arrow'):
        target_zoom = target_zoom*1/.9
        zoom_label.text = `${int(target_zoom*100)}%`

    if key == 'middle mouse down' or key == 'space':
    # if key == 'middle mouse down' or key == 'h':
        bg.lock_x = False
        bg.lock_y = False
        bg.start_offset = [mouse.x-bg.x , mouse.y-bg.y]
        bg.dragging = True

    if key == 'middle mouse up' or key == 'space up':
    # if key == 'middle mouse up' or key == 'h up':
        bg.lock_x = True
        bg.lock_y = True
        bg.dragging = False

    if key == 'f':
        SMUDGE = True

    if key == 'up arrow':
        for layer in layers:
            const img_data = flip_image_data_horizontally(layer.ctx.getImageData(0, 0, layer.canvas.width, layer.canvas.height))
            layer.ctx.putImageData(img_data, 0, 0)

    if key == 'left arrow':
        for layer in layers:
            const img_data = flip_image_data_vertically(layer.ctx.getImageData(0, 0, layer.canvas.width, layer.canvas.height))
            layer.ctx.putImageData(img_data, 0, 0)


def flip_image_data_horizontally(img_data):
    for (let y = 0; y < img_data.height; y++):
        for (let x = 0; x < img_data.width / 2; x++):
            const i = (y * img_data.width+x) * 4
            const j = (y * img_data.width+(img_data.width - x - 1)) * 4
            const tmp = [img_data.data[i], img_data.data[i+1], img_data.data[i+2], img_data.data[i+3],
            ]
            img_data.data[i] = img_data.data[j]
            img_data.data[i+1] = img_data.data[j+1]
            img_data.data[i+2] = img_data.data[j+2]
            img_data.data[i+3] = img_data.data[j+3]
            img_data.data[j] = tmp[0]
            img_data.data[j+1] = tmp[1]
            img_data.data[j+2] = tmp[2]
            img_data.data[j+3] = tmp[3]

    return img_data

def flip_image_data_vertically(imageData):
    const temp = new Uint8ClampedArray(imageData.data.length);

    for (let i = 0; i < imageData.height; i++):
        const srcOff = i * imageData.width * 4;
        const dstOff = (imageData.height - i - 1) * imageData.width * 4;
        temp.set(imageData.data.subarray(srcOff, srcOff + imageData.width * 4), dstOff);

    imageData.data.set(temp);

    return imageData


def update():
    if mouse.hovered_entity == bg:
        if not held_keys['alt'] and not held_keys['h'] and current_tool == brush_tool: # if not sampling color
            document.body.style.cursor = 'none'
        else:
            document.body.style.cursor = 'crosshair'

        if mouse.point:
            brush_cursor.xy = mouse.point
        # document.body.style.cursor = `url('${brush_canvases[0].toDataURL()}') ${brush_size[0]/2} ${brush_size[1]/2}, auto`
    else:
        document.body.style.cursor = 'auto'


    # brush_size = [e*mouse.pressure for e in brush]

color_menu = Entity(parent=camera.ui, visible_self=False, position=[left_button_x,.465,-1])
color_menu.menu = Entity(parent=color_menu, visible_self=False, enabled=1, scale=[.1,.2], enabled=True)

# def color_menu_input(key):
#     if key == 'c':
#         color_menu.menu.enabled = not color_menu.menu.enabled
# color_menu.input = color_menu_input

slider_height = .075
sunsnake.define(*color_slider_style, parent=color_menu.menu, scale_y=.075, roundness=.1, draggable=True, lock_x=True, lock_y=True)
# color_menu_bg = Entity(parent=color_menu.menu, x=.15, scale=[1.05+.3, (slider_height*1.1*3)+.05], color=color.black, alpha=.8, roundness=.05, z=2, ignore_collision=False)
color_preview = Entity(parent=color_menu.menu, scale=[1, slider_height*2], y=-.25, origin=[0,0], roundness=.25)
lighter_color_button = Entity(parent=color_preview, x=.5, origin=[.5,0], scale=[.2,1], roundness=color_preview.roundness)
darker_color_button = Entity(parent=color_preview, x=-.5, origin=[-.5,0], scale=[.2,1], roundness=color_preview.roundness)

for preview in [lighter_color_button, darker_color_button]:
    let e = preview
    e.on_click = def():
        set_color(e.color)


def move_color_slider(slider):
    slider.indicator.x = mouse.point[0]
    set_color(hsv(int((hue_slider.indicator.x+.5)*360), (sat_slider.indicator.x+.5)*1, (val_slider.indicator.x+.5)*1), move_sliders=False)

hue_slider = Entity(*color_slider_style, y=slider_height*1.5, texture='rainbow.png', name='hue_slider')
hue_slider.indicator = Entity(parent=hue_slider, scale_x=.015, color=color.black, z=-2)
hue_slider.while_dragging = def():
    move_color_slider(hue_slider)
hue_slider.on_click = hue_slider.while_dragging

sat_slider = Entity(*color_slider_style, y=0)
sat_slider.overlay = Entity(parent=sat_slider, texture='horizontal_gradient.png', y=0, z=-1, roundness=.15)
sat_slider.indicator = Entity(parent=sat_slider, scale_x=.015, color=color.black, z=-2)
sat_slider.while_dragging = def():
    move_color_slider(sat_slider)
sat_slider.on_click = sat_slider.while_dragging

val_slider = Entity(*color_slider_style, y=-slider_height*1.5)
val_slider.overlay = Entity(parent=val_slider, texture='horizontal_gradient.png', color=color.black, rotation=180, y=0, z=-1, roundness=.15)
val_slider.indicator = Entity(parent=val_slider, scale_x=.015, color=color.black, z=-2)
val_slider.while_dragging = def():
    move_color_slider(val_slider)
val_slider.on_click = val_slider.while_dragging

def set_color(value, move_sliders=True):
    if len(value) == 3:
        value.append(255)

    # print('set color:', value)
    current_color = value
    color_preview.color = current_color
    color_as_hsv = rgb_to_hsv(current_color)
    color_saturated = hsv(color_as_hsv[0], 1, color_as_hsv[2])
    color_desaturated = hsv(color_as_hsv[0], 0, color_as_hsv[2])
    sat_slider.color = color_saturated
    # sat.overlay.color = rgb(color_desaturated[0]/255, color_desaturated[1]/255, color_desaturated[2]/255)
    # sat.overlay.alpha = current_color[3]/255
    hue = color_as_hsv[0] - 10
    if hue < 0:
        hue = 360 + hue
    lighter_color_button.color = hsv(hue, clamp(color_as_hsv[1]-.05,0,1), clamp(color_as_hsv[2]+.1, 0, 1))
    hue = color_as_hsv[0] + 10
    if hue < 0:
        hue = hue - 360
    darker_color_button.color = hsv(hue, color_as_hsv[1]+.05, color_as_hsv[2]-.1)

    if move_sliders:
        hue_slider.indicator.x = -.5 + color_as_hsv[0]/360
        sat_slider.indicator.x = -.5 + color_as_hsv[1]
        val_slider.indicator.x = -.5 + color_as_hsv[2]



for i, e in enumerate(brushes):
    let brush = e
    let brush_button = *Button(x=-.1, y=.295+(.055*-floor(i/2)), roundness=.01)
    if i%2 == 0:
        brush_button.x = left_button_x
    else:
        brush_button.x = right_button_x

    if not e.textures:
        if e.shape == 'rect':
            icon = Entity(roundness=0, parent=brush_button, xy=[-.5,-.5], color=color.white, z=-1, scale=.6, alpha=.75)
        if e.shape == 'circle':
            icon = Entity(roundness=.5, parent=brush_button, xy=[-.5,-.5], color=color.white, z=-1, scale=.6, alpha=.75)
    else:
        icon = Entity(roundness=.01, parent=brush_button, xy=[-.5,-.5], color=color.black, z=-1, scale=.8, alpha=.75)
        icon.texture = `assets/${e.textures[0]}`
        icon_aspect = brush.size[0] / brush.size[1]
        if icon_aspect > 1:
            icon.scale = [.8, icon_aspect*.8]
        else:
            icon.scale = [icon_aspect*.8, .8]

    brush_button.on_click = def():
        set_brush(brush)


# eyedropper = Entity(name='eyedropper', visible_self=False)
# eyedropper.update = def eyedropper_update():
#     if mouse.left:
#         print('smaple')
#         if mouse.hovered_entity == bg:
#             pos = get_canvas_position()
#             current_color = current_layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
#             set_color(current_color)
#             return
#
#         elif mouse.hovered_entity:
#             set_color(mouse.hovered_entity.color)

window.onfocus = def():
    set_current_tool(brush_tool)
    for key, value in held_keys:
        if value:
            held_keys[key] = 0


save_button = *Button(xy=[(-.5*aspect_ratio)+.06,.5], origin=[-.5,.5], scale=[.05,.025], text='save', text_size=1)
save_button.on_click = def save():
    save_file(current_layer.canvas)
    # dataURL = canvas.toDataURL("image")
    # window.localStorage.setItem("image", dataURL)
save_button.input = def input(key):
    if held_keys['shift'] and key == 's':
        save_button.on_click()


def copy_selection():
    if selection.active:
        selection_x = selection.bounds[0]
        selection_y = selection.bounds[1]
        selection_width = selection.bounds[2] - selection.bounds[0]
        selection_height = selection.bounds[3] - selection.bounds[1]

        image_data = current_layer.ctx.getImageData(selection_x, selection_y, selection_width, selection_height)

        i = 0
        for y in range(selection_height):
            for x in range(selection_width):
                image_data.data[i+3] *= int(selection.matrix[selection_x+x][selection_y+y])
                i += 4

        return image_data


async def paste(e):
    e.preventDefault()
    e.stopPropagation()
    paste_data = e.clipboardData.items[0]
    # print('paste data', paste_data)

    if paste_data.kind == 'string':
        paste_data.getAsString(def anon(value):
            # print('paste local data', value)
            if value.startsWith('local_image:'):
                [data, _x, _y, _w, _h] = JSON.parse(value.split('local_image:')[1])
                values = []
                for key, value in data.items():
                    values.append(value)

                data = new Uint8ClampedArray(values)
                image_data = new ImageData(data, _w, _h)
                current_layer.ctx.putImageData(image_data, _x, _y)
                record_undo()
        )
        return False

    file = paste_data.getAsFile()
    if file.name == 'image.png':
        var URLObj = window.URL || window.webkitURL;
        var source = URLObj.createObjectURL(file);
        print('-----', source)
        loaded_image = new Image();
        loaded_image.onload = def on_load():
            current_layer.ctx.clearRect(0, 0, w, h)
            current_layer.ctx.drawImage(loaded_image, 0, 0)

        loaded_image.src = source
        # current_layer.ctx.drawImage(pastedImage, 0, 0)
        # after .01:
        #     current_layer.ctx.drawImage(pastedImage, 0, 0)
        record_undo()

window.addEventListener("paste", paste)


# download_button = *Button(text='download', scale=[.1,.04], origin=[.5,.5], x=(.5*aspect_ratio)-.0125, y=-.42)
# var link = document.createElement('a');
# download_button.on_click = def download():
#     link.download = "untitled.png"
#     # download_button.href = canvas.toDataURL()
#     link.href = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream")
#
#     link.click()
#     print('download')


def undo():
    if undo_index > 0:
        undo_index -= 1

    # [type, data] = undo_data[undo_index]
    # print('ddd', type, data)
    # if type == 'paint_stroke':
    #     [layer, data] = data
    #     var loaded_image = new Image
    #     loaded_image.src = data
    #     loaded_image.onload = def on_load():
    #         layer.ctx.clearRect(0, 0, w, h)
    #         layer.ctx.drawImage(loaded_image, 0, 0)

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def on_load():
        current_layer.ctx.clearRect(0, 0, w, h)
        current_layer.ctx.drawImage(loaded_image, 0, 0)

def redo()
    if undo_index < undo_data.length-1:
        undo_index += 1

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def():
        current_layer.ctx.clearRect(0, 0, w, h)
        current_layer.ctx.drawImage(loaded_image, 0, 0)


def record_undo():
    if undo_data.length > undo_index+1:
        undo_data.splice(undo_index+1)
        # print('delete old undo data')

    undo_data.push(current_layer.canvas.toDataURL())
    # undo_data.push(['paint_stroke', [current_layer, current_layer.canvas.toDataURL()]])
    print('record undo')
    undo_index += 1


selection = {'active':False, 'points':[], 'matrix':Array_2d(w,h,default_value=False), 'bounds':[w,h,0,0]}

def render_selection():
    selection.active = False
    selection_ctx.clearRect(0, 0, w, h)
    selection.bounds = [w,h,0,0]
    for y in range(h):
        for x in range(w):
            if selection['matrix'][x][y]:
                selection.bounds[0] = min(x, selection.bounds[0]) # min x
                selection.bounds[2] = max(x, selection.bounds[2]) # max x
                selection.bounds[1] = min(y, selection.bounds[1]) # min y
                selection.bounds[3] = max(y, selection.bounds[3]) # max y

                selection.active = True
                if x == 0 or x == w or y == 0 or y == h:
                    continue
                # selection_ctx.fillRect(x, y, 1, 1);

                if not selection['matrix'][x-1][y] or not selection['matrix'][x+1][y] or not selection['matrix'][x][y-1] or not selection['matrix'][x][y+1]:
                    if x % 2 == 0:
                        selection_ctx.fillStyle = 'cyan'
                    else:
                        selection_ctx.fillStyle = 'violet'

                    selection_ctx.fillRect(x, y, 1, 1);
    # print('selection bounds', selection.bounds)

lasso_tool = Entity(enabled=False, visible_self=False)
lasso_tool.input = def lasso_tool_input(key):
    if key == 'left mouse down' and mouse.hovered_entity == bg:
        pos = get_canvas_position()
        lasso_prev_pos = pos
        selection.points = []
        if not held_keys['shift'] and not held_keys['alt']:
            selection.matrix = Array_2d(w,h)
            render_selection()
            # print('clear selection')
        lasso_tool.start_point = pos


    elif key == 'left mouse up':
        # print('END SELECTION')
        start = lasso_tool.start_point
        end = selection.points[len(selection.points)-1]
        if not start or not end:
            return
        dist = distance(start, end)
        if not dist:
            return

        for i in range(0, dist):
            t = i / dist
            let _x = int(lerp(start[0], end[0], t))
            let _y = int(lerp(start[1], end[1], t))
            if _x < 0 or _y < 0 or _x > w-1 or _y > h-1:
                continue

            if not [_x,_y] in selection.points:
                selection.points.append([_x,_y])
                selection.matrix[_x][_y] = not held_keys['alt']

        unique_selection = []

        for a in selection.points:
            is_duplicate = False
            for b in unique_selection: # if a in unique_selection: contine
                if a[0]===b[0] and a[1]===b[1]:
                    is_duplicate = True
                    break

            if is_duplicate:
                continue

            unique_selection.append(a)
        selection.points = unique_selection

        xs = [e[0] for e in selection.points]
        ys = [e[1] for e in selection.points]

        selection.min_x = min(...xs)
        selection.max_x = max(...xs)
        selection.min_y = min(...ys)
        selection.max_y = max(...ys)
        # #
        # selection.width = (selection.max_x - selection.min_x) +1
        # selection.height = (selection.max_y - selection.min_y) +1



        poly = selection.points
        clean_poly = [poly[0], ]
        for i in range(0, len(poly), 10):
            if distance(clean_poly[-1], poly[i]) > 32:
                clean_poly.append(poly[i])
        poly = clean_poly

        for y in range(selection.min_y, selection.max_y):
            for x in range(selection.min_x, selection.max_x):
                if inside([x,y], poly):
                    selection.matrix[x][y] = not held_keys['alt']

                # selection.matrix[x][y] = not held_keys['alt'] * inside([x,y], poly)
                    # selection.active = True

        lasso_prev_pos = None
        render_selection()

def inside(point, poly):
    # // ray-casting algorithm based on
    # // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html
    var x = point[0], y = point[1]
    var inside = False

    for (var i=0, j=poly.length-1; i < poly.length; j=i++):
        var xi = poly[i][0], yi = poly[i][1];
        var xj = poly[j][0], yj = poly[j][1];

        intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
        if intersect:
            inside = !inside;

    return inside

def get_pixel(x, y):
    return current_layer.ctx.getImageData(x, y, 1, 1).data
def set_pixel(x, y, color):
    # current_layer.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`
    current_layer.ctx.fillRect(x, y, 1, 1);

# paint_bucket = Entity(visible_self=False)
# margin = 3
# pixel_grid = None
# paint_bucket.input = def paint_bucket_input(key):
#     if key == 'g' and mouse.hovered_entity == bg:
#         current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
#
#         if held_keys['shift']:
#             print('fill')
#             pixel_grid = Array_2d(w, h)
#             for _y in range(h):
#                 for _x in range(w):
#                     pixel_grid[_x][_y] = get_pixel(_x, _y)
#
#             [x, y] = get_canvas_position()
#             floodfill(x, y)
#
#         else:
#             [x, y] = get_canvas_position()
#             color_to_replace = get_pixel(x, y)
#             for y in range(h):
#                 for x in range(w):
#                     pixel = get_pixel(x, y)
#                     if abs(pixel[0]-color_to_replace[0]) <= margin and abs(pixel[1]-color_to_replace[1]) <= margin and abs(pixel[2]-color_to_replace[2]) <= margin:
#                         current_layer.ctx.fillRect(x, y, 1, 1);
#
# fill_stack = []
# def floodfill(x, y):
#     fill_stack.push([x, y])
#     color_to_replace = pixel_grid[x][y]
#
#     while (fill_stack.length > 0):
#         # if held_keys['escape']:
#         #     break
#
#         var [x, y] = fill_stack.pop();
#
#         if x < 0 or x >= w or y < 0 or y >= h:
#             continue
#
#         pixel = pixel_grid[x][y]
#         if abs(pixel[0]-color_to_replace[0]) > margin or abs(pixel[1]-color_to_replace[1]) > margin or abs(pixel[2]-color_to_replace[2]) > margin:
#             continue
#
#         pixel_grid[x][y] = current_color
#         set_pixel(x, y, current_color)
#
#         fill_stack.push([x + 1, y]);
#         fill_stack.push([x - 1, y]);
#         fill_stack.push([x, y + 1]);
#         fill_stack.push([x, y - 1]);


lasso_prev_pos = None

lasso_tool.update = def():
    if not mouse.left:
        return

    pos = get_canvas_position()
    dist = distanceApprox(lasso_prev_pos, pos)
    if not dist:
        return

    for i in range(0, dist):
        t = i / dist
        let _x = int(lerp(lasso_prev_pos[0], pos[0], t))
        let _y = int(lerp(lasso_prev_pos[1], pos[1], t))

        if _x < 0 or _y < 0 or _x > w-1 or _y > h-1:
            continue

        if not [_x,_y] in selection.points:
            selection.points.append([_x,_y])
            selection.matrix[_x][_y] = not held_keys['alt']
            if _x % 2 == 0:
                selection_ctx.fillStyle = 'pink'
                selection_ctx.fillRect(_x, _y, 1, 1);
            # else:
            #     selection_ctx.fillStyle = 'magenta'

    lasso_prev_pos = pos
    # if not [x,y] in selection:
    #     selection.append([x,y])
    #     ctx.fillStyle = rgb(0/255, 0/255, 0/255, 255/255)
    #     ctx.fillRect(x, y, 2, 2);

rect_select_tool = Entity(name='rect_select_tool', visible_self=False, enabled=False)
rect_select_tool.input = def rect_select_tool_input(key):
    if key == 'left mouse down':
        self.start_pos = get_canvas_position()
        if not held_keys['shift'] and not held_keys['alt']:
            selection.points = []
            selection.matrix = Array_2d(w,h)
            # print('clear selection')

    if key == 'left mouse up' and self.start_pos:
        self.end_pos = get_canvas_position()
        start_y = min(self.start_pos[1], self.end_pos[1])
        end_y =  max(self.start_pos[1], self.end_pos[1])
        start_x = min(self.start_pos[0], self.end_pos[0])
        end_x =  max(self.start_pos[0], self.end_pos[0])
        start_y = clamp(start_y, 0, h-1)
        end_y = clamp(end_y, 0, h-1)
        start_x = clamp(start_x, 0, w-1)
        end_x = clamp(end_x, 0, w-1)

        for y in range(start_y, end_y):
            for x in range(start_x, end_x):
                selection.matrix[x][y] = not held_keys['alt']

        render_selection()

transform_tool = Entity(parent=canvas_entity, visible_self=False, enabled=False, draggable=True)

transform_tool.input = def transform_tool_input(key):
    if key == 'left mouse down' and not held_keys['control'] and not held_keys['shift'] and not held_keys['alt']:
        transform_tool.xyz = current_layer.xyz
        current_layer.parent = transform_tool
        current_layer.xy = [0,0]
    elif key == 'left mouse up':
        current_layer.parent = canvas_entity
        current_layer.xy = transform_tool.xy
        # current_layer.scale = current_layer.scale

        # current_layer.dragging = False
        # current_layer.draggable = False
# current_layer.draggable=True

tools = [brush_tool, lasso_tool, rect_select_tool, transform_tool]

current_tool = None
def set_current_tool(tool):
    prev_tool = current_tool
    current_tool = tool
    for e in tools:
        if e != tool:
            e.enabled = False
        else:
            e.enabled = True

set_current_tool(brush_tool)

tool_toggler = Entity(visible_self=False)
tool_toggler.input = def tool_toggler_input(key):
    if key in ['b',]:
        set_current_tool(brush_tool)
        SMUDGE = False
        ERASING = False
    # elif key == 'alt' and current_tool == brush_tool:
    #     set_current_tool(eyedropper)
    # elif key == 'alt up' and current_tool == eyedropper:
    #     set_current_tool(brush_tool)
    elif key == 'e':
        ERASING = True
        set_current_tool(brush_tool)

    elif key in ['l','p']:
        set_current_tool(lasso_tool)
    elif key == 'm':
        set_current_tool(rect_select_tool)
    elif key == 'v' and not held_keys['control']:
        set_current_tool(transform_tool)

file_handler = Entity(visible_self=False)
file_handler.input = def file_handler_input(key):
    if key == 'o':
        open_file()

async def open_file():
    const pickerOpts = {types: [{description: "Images", accept:{"image/*": [".png", ".gif", ".jpeg", ".jpg"],},},], excludeAcceptAllOption: true, multiple: false};
    const [fileHandle] = await window.showOpenFilePicker(pickerOpts)
    const file = await fileHandle.getFile()
    const reader = new FileReader();
    _IMG = new Image()

    reader.addEventListener('load', (event) => :
        _IMG.onload = def():
            new_document(this.width, this.height)
            current_layer.ctx.drawImage(_IMG,0,0)
            record_undo()

        _IMG.src = event.target.result;
    )
    reader.readAsDataURL(file);


async def save_file(canvas, suggested_name='untitled.png'):
    const options = {
    types: [{
      description: 'png transparent',
      accept: {'image/png': ['.png'],},
    },
    {
      description: 'png opaque',
      accept: {'image/png': ['.png'],},
    }
    ],
    suggestedName: suggested_name
    }
    const newHandle = await window.showSaveFilePicker(options)
    const writableStream = await newHandle.createWritable()

    imgBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    await writableStream.write(imgBlob)
    await writableStream.close()


document.ondrop = def ondrop(event):
    event.preventDefault()
    files = [e for e in event.dataTransfer.files]
    if not files:
        return False


    let reader = new FileReader()
    reader.onloadend = def():
        img = new Image()
        img.src = reader.result
        img.onload = def():
            # print('aaaaaaaaaaaaaaa', img)
            new_document(img.width, img.height)
            current_layer.ctx.drawImage(img, 0, 0)
            record_undo()
    reader.readAsDataURL(files[0])


document.ondragover = def ondragover(event):
    event.preventDefault()

window.onbeforeunload = def():
    if not held_keys['shift']:
        return "Data will be lost if you leave the page, are you sure?"


new_document(1920, 1080)
set_layer(first_layer)

if '?' in window.location.href:
    args = window.local_image.href.split('?',1)[1]
    print('---------------', args)


class RadialMenu extends Entity:
    constructor(kwargs):
        let settings = dict(parent=camera.ui, visible_self=False, active=False, shortcut=None)
        for key, value in kwargs.items():
            settings[key] = value

        super(settings)
        this.buttons = settings['buttons']
        this.menu = Entity(parent=this, visible_self=False, enabled=settings['active'])
        this._center_indicator = Entity(parent=this.menu, scale=.05, color=color.azure, shadow=True, alpha=.5, roundness=.5)
        this.line = Entity(parent=this.menu, scale=[.5, .005], origin=[-.5,0], color=color.azure, z=-2, roundness=.5)
        this.bg = Entity(parent=this.menu, z=0, color=color.black, alpha=.25, scale=10)
        this.selected_button = None
        for i, b in enumerate(this.buttons):
            b.parent = this.menu
            let angle = (Math.PI/2) -(i / (len(this.buttons)/2)) * Math.PI
            b.x = (.15 * Math.cos(angle))
            b.y = (.15 * Math.sin(angle))

    update():
        this.line.scale_x = distance(this.menu.xy, mouse.position)
        this.line.look_at([mouse.position[0]-this.menu.x, mouse.position[1]-this.menu.y])

        if distance(this.menu.xy, mouse.position) < .1:
            this.selected_button = None
            for e in this.buttons:
                e.color = color.black
            return

        let angle = this.line.rotation + 90 + (180/len(this.buttons))
        if angle < 0:
            angle = 360 + angle

        this.selected_button = this.buttons[int(angle / 360 * len(this.buttons))]

        for e in this.buttons:
            e.color = color.black
        this.selected_button.color = color.azure

    input(key):
        if key == this.shortcut:
            this.menu.xy = mouse.position
            this.menu.enabled = True
        elif key == this.shortcut + ' up':
            this.menu.enabled = False
            if this.selected_button:
                this.selected_button.on_click()


sunsnake.define(*ShortcutMenuButton(,Button(roundness=.5, scale=.1, color=color.black, text_color=color.white, alpha=.75, text_size=1.5, ignore_collision=False, )
save_selected_button = *ShortcutMenuButton(text='download \nselection')
canvas_for_saving = document.createElement('canvas');

save_selected_button.on_click = def():
    if not selection.active:
        return
    image_data = copy_selection()

    canvas_for_saving.width = image_data.width
    canvas_for_saving.height = image_data.height
    canvas_for_saving.getContext('2d').clearRect(0, 0, image_data.width, image_data.height)
    canvas_for_saving.getContext('2d').putImageData(image_data, 0, 0)
    save_file(canvas_for_saving)


select_layer_above_button = *ShortcutMenuButton(text='select layer \nabove')
select_layer_above_button.on_click = def():
    current_layer_index = clamp(layers.index(current_layer)+1, 0, len(layers)-1)
    set_layer(layers[current_layer_index])

select_layer_below_button = *ShortcutMenuButton(text='select layer \nbelow')
select_layer_below_button.on_click = def():
    current_layer_index = clamp(layers.index(current_layer)-1, 0, len(layers)-1)
    set_layer(layers[current_layer_index])

empty = *ShortcutMenuButton(text='---')
_save_button = *ShortcutMenuButton(text='save')
_SW = *ShortcutMenuButton(text='lasso', on_click=def():set_current_tool(lasso_tool))
_W = *ShortcutMenuButton(text='brush', on_click=def():set_current_tool(brush_tool); ERASING=False)
_NW = *ShortcutMenuButton(text='erase', on_click=def():set_current_tool(brush_tool); ERASING=True)


_buttons = [
    select_layer_above_button,
    empty,
    _save_button,
    save_selected_button,
    select_layer_below_button,
    _SW,
    _W,
    _NW,
    ]

radial_menu = RadialMenu(buttons=_buttons, shortcut='a')
Entity(visible_self=False).input = def input(key):
    if key == 'right mouse down' and not held_keys['control']:
        radial_menu.input(radial_menu.shortcut)
    if key == 'right mouse up':
        radial_menu.input(radial_menu.shortcut + ' up')


hsv_menu_handler = Entity(visible_self=False)
hsv_menu_handler.input = def input(key):
    if key == 'u':
        hsv_menu.enabled = not hsv_menu.enabled

hsv_menu = Entity(scale=[.25*2,.125*2], enabled=False, roundness=.05, shadow=True, parent=camera.ui, color=color.black, alpha=.8, text_origin=[0,.5], text='HSV', text_color=color.light_gray, text_size=2, ignore_collision=False)
hsv_menu.on_enable = def():
    hsv_menu.original_data = current_layer.ctx.getImageData(0, 0, w, h).data
    print('get fresh')

hsv_menu.close = def():
    hsv_menu.enabled = False
    hsv_menu.hue_slider.value = 180
    hsv_menu.sat_slider.value = 50
    hsv_menu.val_slider.value = 50

    if hsv_menu.original_data:
        current_layer.ctx.putImageData(new ImageData(hsv_menu.original_data, w, h), 0, 0)
        print('reset')

hsv_menu.apply_button = Button(parent=hsv_menu, text='Apply', color=color.pink, text_color=color.white, scale=[.4,.15], x=.025, y=-.35, text_size=2, roundness=.5, origin=[-.5,0])
hsv_menu.apply_button.on_click = def():
    hsv_menu.enabled = False
    record_undo()

hsv_menu.discard_button = Button(parent=hsv_menu, text='Discard', color=color.gray, text_color=color.white, scale=[.4,.15], x=-.025, y=-.35, text_size=2, roundness=.5, origin=[.5,0], on_click=hsv_menu.close)
hsv_menu.close_button = Entity(parent=hsv_menu, text='x', scale=[.05,.1], color=color.red, text_color=color.white, text_origin=[0,0], text_size=2, roundness=.5, xy=[.5,.5], origin=[.5,0], on_click=hsv_menu.close)
hsv_menu.bg = Entity(parent=hsv_menu, visible_self=False, scale=10, on_click=hsv_menu.close, z=1)
hsv_menu.hue_slider = RainbowSlider(parent=hsv_menu, min=0, max=360, default=180, prev_value=180, y=.3)
hsv_menu.sat_slider = RainbowSlider(parent=hsv_menu, min=0, max=100, default=50, prev_value=50, y=.15)
hsv_menu.val_slider = RainbowSlider(parent=hsv_menu, min=0, max=100, default=50, prev_value=50, y=0)
hsv_menu.colorize_toggle_parent = Button(parent=hsv_menu, scale=[.1,.1], roundness=.1, text_origin=[-.5,0], text=' Colorize:', value=False, xy=[-.325,-.15], origin=[0,0], text_size=1, text_color=color.white, color=color.clear)
hsv_menu.colorize_toggle = Button(parent=hsv_menu.colorize_toggle_parent, scale=[.5,1], roundness=.1, text_origin=[0,0], text=' ', value=False, xy=[.5,0], origin=[-.5,0], text_size=2, color=color.dark_gray, text_color=color.white)
hsv_menu.colorize_toggle.on_click = def():
    hsv_menu.colorize_toggle.value = not hsv_menu.colorize_toggle.value
    hsv_menu.colorize_toggle.text = [' ', 'âœ“'][int(hsv_menu.colorize_toggle.value)]
    apply_hsv_filter()

def apply_hsv_filter():
    if not hsv_menu.colorize_toggle.value:
        apply_relative_hsv_adjustment(hsv_menu.hue_slider.value - 180, (hsv_menu.sat_slider.value-50)/100, (hsv_menu.val_slider.value-50)/100)
    else:
        apply_absolute_hsv_adjustment(hsv_menu.hue_slider.value, hsv_menu.sat_slider.value/100, hsv_menu.val_slider.value/100)


hsv_menu.hue_slider.on_value_changed = apply_hsv_filter
hsv_menu.sat_slider.on_value_changed = apply_hsv_filter
hsv_menu.val_slider.on_value_changed = apply_hsv_filter


def apply_relative_hsv_adjustment(hue, sat, val):
    new_data = new Uint8ClampedArray(hsv_menu.original_data);

    for i in range(0, len(new_data), 4)
        _color_as_hsv = rgb_to_hsv([new_data[i], new_data[i+1], new_data[i+2]])
        _color_as_hsv = [_color_as_hsv[0]+hue, _color_as_hsv[1]+sat, _color_as_hsv[2]+val]
        if _color_as_hsv[0] < 0:
            _color_as_hsv[0] = 360 + _color_as_hsv[0]
        if _color_as_hsv[0] > 360:
            _color_as_hsv[0] = _color_as_hsv[0] - 360

        _rgb_color = hsv(_color_as_hsv[0], _color_as_hsv[1], _color_as_hsv[2])
        new_data[i] = _rgb_color[0]
        new_data[i+1] = _rgb_color[1]
        new_data[i+2] = _rgb_color[2]

    new_image_data = new ImageData(new_data, w, h)
    current_layer.ctx.putImageData(new_image_data, 0, 0)


def apply_absolute_hsv_adjustment(hue, sat, val):
    new_data = new Uint8ClampedArray(hsv_menu.original_data);
    _rgb_color = hsv(hue, sat, val)

    for i in range(0, len(new_data), 4)
        new_data[i] = _rgb_color[0]
        new_data[i+1] = _rgb_color[1]
        new_data[i+2] = _rgb_color[2]

    new_image_data = new ImageData(new_data, w, h)
    current_layer.ctx.putImageData(new_image_data, 0, 0)

set_color(current_color)
# set_color(color.red)

# add_layer()
# add_layer()

</script>

// <script src="https://cdn.cde.run/Joycon.min.js"></script>
//
// <script type="text/sunsnake" src="joycon_input.sunsnake"></script>

<script src="../taptapir/sunsnake_compiler.js"></script>
