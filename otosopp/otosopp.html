<html><title>otosopp</title><body>
<script src="color_conversion.js"></script>
<script src="../taptapir/taptapir.js"></script>
<script src="../taptapir/taptapir_gamepad.js"></script>
<script src="assets/base_64_brushes.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

<script type='text/sunsnake'>


def get_combined_key(key):
    modifier_keys = ['control', 'shift', 'alt']
    combined_key = ''

    for mod_key in modifier_keys:
        if held_keys[mod_key] and mod_key != key:
            combined_key += mod_key + '+'

    combined_key += key
    return combined_key

input_handler = {'get_combined_key':get_combined_key}


set_window_color('#222')
set_background_color('#111')
if browser_aspect_ratio > 1:
    set_orientation('horizontal')
else:
    print('mobile------------------')
    set_orientation('vertical')
set_scale(1)
# set_scale(.5)
canvas_scale = .8
TEXT_SIZE_MULTIPLIER = .5
document.addEventListener('contextmenu', event => event.preventDefault());


bg = Entity(visible_self=False, scale=[2*canvas_scale, 2*canvas_scale], draggable=True, lock_x=True, lock_y=True, ignore_collision=False)

right_menu_bg = Entity(origin=[.5,0], scale=[.115,1], position=right, color=hsv(0,0,.07), alpha=.9, ignore_collision=False)
menu_parent = Entity(parent=camera.ui, visible_self=False)
right_button_x = (.5*aspect_ratio)-.005
left_button_x = right_button_x-.055
sunsnake.define(*Button(,Entity(parent=menu_parent, roundness=.01, origin=[.5,.5], text_origin=[0,0], x=(.5*aspect_ratio)-.01, scale=[.05,.05], z=-1, text_size=1.5, color=hsv(0,0,.03), text_color=hsv(0,.0,.8),)


new_canvas_handler = Entity(visible_self=False)
new_canvas_prompt = Entity(scale=[.25,.125], enabled=False, roundness=.05, shadow=True, parent=camera.ui, color=color.black, text_origin=[0,.5], text=' New Canvas', text_color=color.light_gray, text_size=2, ignore_collision=False)
Entity(parent=new_canvas_prompt, text='x', scale=.1, color=new_canvas_prompt.color, text_color=new_canvas_prompt.text_color, text_origin=[0,0], text_size=2)
new_canvas_prompt.close_button = Entity(parent=new_canvas_prompt, text='x', scale=.2, color=color.red, text_color=color.white, text_origin=[0,0], text_size=2, roundness=.5, xy=[.6,.5], origin=[.5,0], on_click=def():new_canvas_prompt.enabled=False)
w_field = InputField(parent=new_canvas_prompt, scale=(1,.3), origin=[.5,0], x=-.05, value=512)
h_field = InputField(parent=new_canvas_prompt, scale=(1,.3), origin=[-.5,0], x=.05, value=512)
create_button = Button(parent=new_canvas_prompt, color=color.azure, origin=[0,-.5], scale=[.4,.25], roundness=.5, y=-.5, text='Create', text_size=2, text_color=color.light_gray, on_click=def():new_document(w_field.value,h_field.value); new_canvas_prompt.enabled=False)
create_button.input = def input(key):
    if held_keys['control'] and key == 'enter':
        create_button.on_click()
canvas_sizes = [[512,512], [1024,1024], [2048,2048], [1920,1080], [1920*2,1080*2], [2048,1024], [3440,1440]]
for i, size in canvas_sizes:
    let b = *Button(parent=new_canvas_prompt, scale=[.3,1/len(canvas_sizes)], origin=[0,.5], x=-.68, y=.5-(1/len(canvas_sizes)*i), text=`${size}`, text_size=1.25, color=hsv(0,0,0), text_color=color.light_gray, roundness=.5)
    b.on_click = def():
        w_field.value = size[0]
        h_field.value = size[1]


new_canvas_handler.input = def input(key):
    if held_keys['control'] and held_keys['alt'] and key == 'n':
        new_canvas_prompt.enabled = True
    if key == 'escape':
        new_canvas_prompt.enabled = False


resolution_info = *Button(origin=[-.5,-.5], position=bottom_left, scale=[.075,.015], text='??? x ???', roundness=0, alpha=.5, text_size=1)
new_file_button = *Button(position=top_left, origin=[-.5,.5], text='+', scale=[.05,.025], on_click=def():new_canvas_prompt.enabled=True)
info_button = *Button(xy=[(-.5*aspect_ratio)+.125,.5], origin=[-.5,.5], text='â“˜', scale=[.025,.025], ignore_collision=False)
info_button.el.onmouseenter = def():
    info_window.enabled = True
info_button.el.onmouseleave = def():
    info_window.enabled = False

info_text = `Shortcuts:
[b] brush
[x] smaller brush
[s] bigger brush
[e] erase
[l] lasso select tool
[m] rect select tool
[ctrl+z] undo
[ctrl+y] redo
[alt] sample color
[ctrl+alt] sample current layer
[a] / [right click] radial menu
[u] draw under
[i] draw inside
[h] flip horizontally
[v] flip vertically
`
info_window = Text(parent=info_button.parent, text=info_text, text_size=1.5, text_color=color.light_gray, color=color.black, alpha=.9, roundness=.005, enabled=False)
info_window.fit_to_text()
info_window.origin=[-.5,.5]
info_window.xy = [info_button.x, info_button.y-info_button.scale_y]
info_window.el.style.fontFamily = 'monospace'

canvas_entity = Entity(parent=bg, color='#606060', scale=[1/2,1/2], z=-1)
canvas_entity.el.style.overflow = 'hidden'
shadow_entity = Entity(parent=bg, scale=canvas_entity.scale, shadow='0px 0px 100px #0008', visible_self=False)


layer_menu = *Button(scale=[.105,.4], origin=[0,-.5], x=((.5*aspect_ratio)-.0125)-.045, y=-.39, visible_self=True, roundness=.005, color=hsv(0,0,.03), ignore_collision=False)

background_color_menu = Entity(parent=layer_menu.parent, x=layer_menu.x, origin=layer_menu.origin, y=layer_menu.y-.0125, visible_self=False, scale=[layer_menu.scale_x*.95, .010], z=1, alpha=.4)
for i, col in ['#000000', '#404040', '#606060', '#bfbfbf', '#ffffff']:
    let change_bg_color_button = *Button(parent=background_color_menu, x=-.5+(i/5), color=col, origin=[-.5,-.5], scale=[1/6,1], roundness=.25, on_click=def():canvas_entity.color=col)

add_layer_button = *Button(text='+', scale=[layer_menu.scale_x/2,.03], roundness=.005, origin=[.5,-.5], x=layer_menu.x, y=layer_menu.y-.05, on_click=add_layer)
delete_layer_button = *Button(text='-', scale=[layer_menu.scale_x/2,.03], roundness=.005, origin=[.5,-.5], x=layer_menu.x+layer_menu.scale_x/2, y=layer_menu.y-.05, on_click=delete_layer)

def add_layer(name='layer', _w=W, _h=H, enabled=True, select=True):
    if name == 'layer':
        name = `layer ${len(layers)}`
    let layer = Entity(name=name, parent=canvas_entity, color=color.clear, z=-1, enabled=enabled)
    layers.append(layer)

    layer.canvas = document.createElement('canvas');
    layer.canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
    layer.canvas.width = _w
    layer.canvas.height = _h
    layer.model.appendChild(layer.canvas)

    layer.ctx = layer.canvas.getContext('2d', {willReadFrequently: true})

    # print('--------------------hidden:', not enabled)
    if not enabled:
        return layer

    layer.layer_button = Button(enabled=enabled, x=layer_menu.x, origin=[0,-.5], scale=[.105,.03], roundness=.1, y=layer_menu.y+((len(layers)-1)*1.01*.03), text_size=1, text=name, text_color=color.light_gray,
        draggable=True, lock_x=True, min_y=layer_menu.y-.015, max_y=layer_menu.y+layer_menu.scale_y+.015, color=hsv(0,0,.1), layer=layer)
    layer.layer_button.original_color = layer.layer_button.color
    layer.layer_button.on_click = def():
        set_layer(layer)
    layer.layer_button.drop = def():
        layer_buttons = [l.layer_button for l in layers]
        def sort_by_y(first, second):
            return first.y - second.y

        layer_buttons.sort(sort_by_y)
        for i, lb in layer_buttons:
            lb.y = layer_menu.y+((i)*1.01*.03)

        layers = [lb.layer for lb in layer_buttons]
        set_layer(layer)


    layer.opacity_slider = RainbowSlider(parent=layer.layer_button, scale=[1,.2], x=.0, y=.125, z=-2, show_lines=True, max=20, color=color.red, default=20, gradient=[hsv(210,.5,.6,), ], alpha=.75)
    # layer.opacity_slider.bar.alpha = .25
    layer.opacity_slider.on_value_changed = def():
        layer.canvas.style.opacity = layer.opacity_slider.value/layer.opacity_slider.max

    let toggle_layer_visibility_button = Button(parent=layer.layer_button, origin=[-.5,-.5], x=-.48, y=.3, scale=[.2,.6], roundness=.1, alpha=.25, text_size=2, z=-1, color=color.black, text='', text_color=color.white)
    toggle_layer_visibility_button.on_click = def():
        layer.enabled = not layer.enabled
        text = ' '
        if not layer.enabled:
            text = 'H'
        toggle_layer_visibility_button.text = text

    if select:
        set_layer(layer)

    return layer

def delete_layer(layer=current_layer):
    if len(layers) == 0:
        return

    current_layer


W = 1920
H = 1080
layers = []
DOCUMENT_NAME = 'untitled'

def new_document(width, height, fill_color=color.clear):
    for e in layers:
        destroy(e)
    layers = []

    W = width
    H = height
    canvas_aspect = W/H
    print('new_document', canvas_aspect)
    bg.scale = [2*canvas_scale*canvas_aspect, 2*canvas_scale]
    selection_canvas.width = W
    selection_canvas.height = H

    first_layer = add_layer()
    if fill_color == color.clear:
        first_layer.ctx.clearRect(0, 0, W, H)
    else:
        first_layer.ctx.fillStyle = rgb(...fill_color)
        first_layer.ctx.fillRect(0, 0, W, H)

    current_layer = first_layer
    undo_data = [current_layer.canvas.toDataURL("image"), ]
    undo_index = 0

    resolution_info.text = `${W} x ${H}`


def set_layer(layer):
    current_layer = layer
    print('current_layer:', current_layer)
    for i, layer in layers:
        layer.layer_button.color = layer.layer_button.original_color
        layer.layer_button.text_color = hsv(0,0,.4)
        layer.z = -i
    # current_layer.layer_button.color = '#333a8b'
    current_layer.layer_button.color = hsv(0,0,.8)
    current_layer.layer_button.text_color = hsv(0,0,.2)


selection_canvas = document.createElement('canvas')
selection_canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
selection_canvas.willReadFrequently = True
selection_canvas.imageSmoothingEnabled = False

selection_canvas_entity = Entity(name='selection_canvas', parent=bg, color=color.clear, scale=[1/2,1/2], z=-1)
selection_canvas_entity.model.appendChild(selection_canvas)

selection_ctx = selection_canvas.getContext('2d', {willReadFrequently: true})
selection_ctx.fillStyle = rgb(128/255, 0/255, 0/255, 255/255)
selection_ctx.clearRect(0, 0, W, H)


heavypaint_dry_brush = {'name':'heavypaint_dry_brush', 'textures':["heavypaint_dry.png", ],'size':[678, 264], 'spacing':.1, 'painterly_brush':True, 'rotate':False, 'draw_on_click':True, 'pressure_stremin_pressurength':1}
heavypaint_dry_brush_2 = {'name':'heavypaint_dry_brush', 'textures':["heavypaint_dry_2.png", ],'size':[678, 264], 'spacing':.1, 'painterly_brush':True, 'rotate':False, 'draw_on_click':True, 'pressure_stremin_pressurength':1}
square_brush = {'name':'square_brush', 'textures':None, 'shape':'rect', 'size':[50, 50], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'pressure_stremin_pressurength':1}
round_brush = {'name':'round_brush', 'textures':None, 'shape':'circle', 'size':[1, 1], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':1}
round_bitmap_brush = {'name':'round_bitmap_brush', 'textures':["round_brush_16.png", ], 'size':[2, 2], 'spacing':.1, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':0}
poke_brush = {'name':'poke_brush', 'textures':["pokebrush.png", ], 'size':[64, 64], 'spacing':.075, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':0}
poke_brush_small = {'name':'poke_brush_small', 'textures':["pokebrush.png", ], 'size':[16, 16], 'spacing':.075, 'painterly_brush':False, 'rotate':False, 'draw_on_click':True, 'min_pressure':1}
poke_brush_scatter = {'name':'poke_brush_scatter', 'textures':["pokebrush.png", 'pokebrush.png'], 'size':[256, 256], 'spacing':.25, 'painterly_brush':False, 'rotate':'random', 'draw_on_click':False, 'min_pressure':1}
painterly_brush = {'name':'painterly_brush', 'textures':["RGBA anim 01.png", "RGBA anim 02.png", "RGBA anim 03.png", "RGBA anim 04.png", ], 'size':[89, 200], 'spacing':.5, 'painterly_brush':True, 'rotate':True, 'draw_on_click':True, 'min_pressure':1}
stubby_brush = {'name':'stubby_brush', 'textures':["RGBA anim 01.png", "RGBA anim 02.png", "RGBA anim 03.png", "RGBA anim 04.png", ], 'size':[64, 64], 'spacing':.5, 'painterly_brush':True, 'rotate':True, 'draw_on_click':True, 'min_pressure':1}
starfield_brush = {'name':'starfield_brush', 'textures':["starfield.png", ], 'size':[256, 256], 'spacing':1, 'painterly_brush':1, 'rotate':'random', 'draw_on_click':True, 'min_pressure':0}
star_brush = {'name':'star_brush', 'textures':["star_brush.png", ], 'size':[128, 128], 'spacing':5, 'painterly_brush':0, 'rotate':False, 'draw_on_click':True, 'min_pressure':0}

brushes = [heavypaint_dry_brush, heavypaint_dry_brush_2, round_brush, square_brush, round_bitmap_brush, poke_brush, poke_brush_small, painterly_brush, stubby_brush, starfield_brush, star_brush, poke_brush_scatter, poke_brush_scatter, poke_brush_scatter, poke_brush_scatter]
current_brush = None
brush_canvases = []
increase_brush_size_button = *Button(x=right_button_x, y=.33, text='+', scale=[.05,.035])
increase_brush_size_button.on_click = def():
    new_brush_size = [e*1.5 for e in brush_size]
    set_brush_size(new_brush_size)
decrease_brush_size_button = *Button(y=.33, x=left_button_x, text='-', scale=[.05,.035])
decrease_brush_size_button.on_click = def():
    new_brush_size = [e*1/1.5 for e in brush_size]
    set_brush_size(new_brush_size)
brush_size_label = *Button(text='??', y=increase_brush_size_button.y+(increase_brush_size_button.scale_y*.55), x=lerp(increase_brush_size_button.x, decrease_brush_size_button.x, .5), scale_y=.025)

def set_brush(brush):
    current_brush = brush

    brush_tips = None
    if brush.textures:
        for e in brush_canvases:
            e.remove()

        brush_tips = [new Image() for e in brush.textures]
        brush_canvases = [document.createElement('canvas') for e in brush_tips]
        for i in range(brush_tips.length):
            # brush_tips[i].src = brush.textures[i]
            brush_tips[i].src = brush_textures[brush.textures[i]]
        # brush_cursor.texture = brush_tips[i].src

    print('set brush', brush)
    set_brush_size(brush.size)
    SPACING = brush.spacing
    using_painterly_brush = brush.painterly_brush
    rotate_brush = brush.rotate
    draw_on_click = brush.draw_on_click

brush_size = [64,64]
brush_cursor = Entity(parent=bg, color=color.clear, scale=.1, z=-10)
brush_cursor.model.style.borderWidth = '1px'
brush_cursor.model.style.borderColor = '#cccccc33'
brush_cursor.model.style.borderStyle = 'solid'
brush_cursor.model.style.borderRadius = '50%'
brush_cursor.update = def brush_cursor_update():
    if mouse.hovered_entity == bg and mouse.point:
        brush_cursor.xy = mouse.point


def set_brush_size(value):
    brush_size = value
    brush_size_label.text = `${brush_size[0]}`
    brush_cursor.scale_x = brush_size[0] / W * canvas_entity.scale_x
    brush_cursor.scale_y = brush_size[1] / H * canvas_entity.scale_y


brush_distance = 0
draw_on_click = False
rotate_brush = True
using_painterly_brush = True
prev_brush_tip = -1
set_brush(painterly_brush)
# set_brush(round_brush)
# set_brush_size([64,64])
IMG = new Image()
current_color = [32, 128, 128, 255]
# print('----------------', random.randint(0,360)/60)
current_color = hsv(random.randint(0,360), 1, 1, 1)
drawing = False
smoothing = False
prev_pos = None
start_position = None
snap_to_hex = False
tool = 'brush'
ERASING = False
SMUDGE = False
SMUDGE_STRENGTH = 1
REPLACE = False
# cursor = Entity(scale=.02, color=color.red, alpha=.1, parent=canvas_entity, enabled=False)

brush_tool = Entity(name='brush_tool', visible_self=False)
brush_tool.on_disable = def():
    brush_cursor.enabled = False
    mouse.visible = True
brush_tool.on_enable = def():
    brush_cursor.enabled = True
    mouse.visible = False

brush_scaling_canvas = document.createElement('canvas')
brush_scaling_canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
brush_scaling_canvas.width = W
brush_scaling_canvas.height = H
brush_scaling_ctx = brush_scaling_canvas.getContext('2d', {willReadFrequently: true})

mask_canvas = document.createElement('canvas')
mask_canvas.style = 'width:100%; height:100%; top:0%; bottom:0%; pointer-events:none;'
mask_canvas.width = W
mask_canvas.height = H
mask_ctx = brush_scaling_canvas.getContext('2d', {willReadFrequently: true})


def update_brush_tip(color):
    if not using_painterly_brush: # tint the temporary brush tip
        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            brush = brush_tips[j]

            print(brush_size[0], mouse.pressure, int(max(brush_size[0] * mouse.pressure, 10)))
            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            if mouse.pressure < 1:
                brush_canvas.width *= mouse.pressure
                brush_canvas.height *= mouse.pressure
            brush_canvas_context = brush_canvas.getContext("2d", {willReadFrequently: true})
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            if not SMUDGE:
                img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

                for i in range(0, img_data.data.length, 4):
                    img_data.data[i] = img_data.data[i] * (color[0]/255)
                    img_data.data[i+1] = img_data.data[i+1] * (color[1]/255)
                    img_data.data[i+2] = img_data.data[i+2] * (color[2]/255)
                    img_data.data[i+3] = img_data.data[i+3] * (color[3]/255)

            elif SMUDGE:
                print('SMUDGE')
            #     # sample the canvas for colors and multiply with brush alpha
                pos = get_canvas_position()
                img_data = current_layer.ctx.getImageData(pos[0]-(brush_size[0]/2), pos[1]-brush_size[1]/2, brush_size[0], brush_size[1])
                brush_pixels = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

                for i in range(0, img_data.data.length, 4):
                    img_data.data[i+3] = img_data.data[i+3] * brush_pixels.data[i+3] * (1/255*SMUDGE_STRENGTH)
                    # img_data.data[i+3] = img_data.data[i+3]
            #     # brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            #     # img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])
            #     # self.smudge_IMG = self.parent.current_layer.img_data.crop((
            #     #         stamp_pos[0], stamp_pos[1],
            #     #         stamp_pos[0]+self.brush.width, stamp_pos[1]+self.brush.height))
            #     #
            #     #     try:
            #     #         self.smudge_IMG.putalpha(self.brush.split()[-1])
            #     #     except:
            #     #         pass

            brush_canvas_context.putImageData(img_data, 0, 0)
    else: # special tint for paiterly brushes to keep contrast
        color_as_hsv = rgb_to_hsv(color)
        c = color_as_hsv[2] * 255
        c = (color[0] + color[1] + color[2])/3
        # print('------------', c)
        sat = color_as_hsv[1]
        contrast = 64
        dark = c-contrast
        light = c+contrast
        # adjust contrast and brighten based on saturation
        dark = c-contrast + (sat*contrast*1.2)
        light = c+contrast + contrast + (sat*contrast*1.2)

        for j in range(brush_tips.length):
            brush_canvas = brush_canvases[j]
            brush = brush_tips[j]

            brush_canvas.width = brush_size[0]
            brush_canvas.height = brush_size[1]
            brush_canvas_context = brush_canvas.getContext("2d", {willReadFrequently: true})
            brush_canvas_context.imageSmoothingEnabled = false
            brush_canvas_context.drawImage(brush, 0, 0, brush_size[0], brush_size[1])
            img_data = brush_canvas_context.getImageData(0, 0, brush_size[0], brush_size[1])

            for i in range(0, img_data.data.length, 4):
                # img_data.data[i] = lerp(dark, light, img_data.data[i]/255) * lerp(1, color[0]/255, sat)
                # img_data.data[i+1] = lerp(dark, light, img_data.data[i+1]/255) * lerp(1, color[1]/255, sat)
                # img_data.data[i+2] = lerp(dark, light, img_data.data[i+2]/255) * lerp(1, color[2]/255, sat)
                img_data.data[i] = lerp(dark, light, img_data.data[i]/255) * color[0]/255
                img_data.data[i+1] = lerp(dark, light, img_data.data[i+1]/255) * color[1]/255
                img_data.data[i+2] = lerp(dark, light, img_data.data[i+2]/255) * color[2]/255
                img_data.data[i+3] = img_data.data[i+3] * color[3]/255

            brush_canvas_context.putImageData(img_data, 0, 0)



brush_tool.input = def brush_tool_input(key):
    if mouse.hovered_entity == bg and key == 'left mouse down':
        if not held_keys['control']:
            prev_pos = None

        drawing = True
        # print('start drawing')
        # temp_ctx.clearRect(0, 0, W, H)
        # current_layer.ctx.putImageData(img_data, x-(brush_size[0]/2), y-(brush_size[1]/2))

        if tool == 'eyedropper' or not brush_tips:
            paint()
            return


        if tool == 'eyedropper':
            drawing = True

        update_brush_tip(current_color)

        try:
            paint()
        catch:
            return

    if drawing and key == 'left mouse up':
        drawing = False
        # print('stop drawing')
        # img_data = temp_ctx.getImageData(0, 0, W, H)
        # current_layer.ctx.putImageData(img_data, 0, 0)
        # current_layer.ctx.drawImage(temp_canvas)
        # temp_ctx.clearRect(0, 0, W, H)
        record_undo()

brush_tool.update = def brush_tool_update():
    if drawing:

        paint()


def get_canvas_position(layer=current_layer):
    if not mouse.point:
        return [0,0]

    pos = mouse.point
    return [int((((pos[0]-(layer.x*.5))*2)+.5) * W), int((((pos[1]-(layer.y*.5))*2)-.5) * -H)]
    # return [int((((pos[0])*2)+.5) * W), int((((pos[1])*2)-.5) * -H)]


def draw_circle(x, y):
    current_layer.ctx.globalAlpha = current_color[3]/255
    current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
    if ERASING:
        current_layer.ctx.globalAlpha = 0
        # current_layer.ctx.fillStyle = `rgba(256, 256, 256, 64)`
        print('aaa')


    if not selection.active:
        # current_layer.ctx.fillRect(x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
        current_layer.ctx.beginPath()
        current_layer.ctx.arc(x, y, brush_size[0], 0, 2*Math.PI)
        current_layer.ctx.fill()
        current_layer.ctx.closePath()
        print('fill')
        return

    brush_half_w = brush_size[0] / 2
    brush_half_h = brush_size[1] / 2

    for _y in range(clamp(y-brush_half_h, 0, H-1), clamp(y+brush_half_h, 0, H-1)):
        for _x in range(clamp(x-brush_half_w, 0, W-1), clamp(x+brush_half_w, 0, W-1)):
            if selection.active and selection.matrix[int(_x)][int(_y)]:
                current_layer.ctx.fillRect(int(_x), int(_y), 1, 1);

def draw_rect(x, y):
    current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
    if not selection.active:
        current_layer.ctx.fillRect(int(x-(brush_size[0]/2)), int(y-(brush_size[1]/2)), brush_size[0], brush_size[1])
        return

    brush_half_w = brush_size[0] / 2
    brush_half_h = brush_size[1] / 2

    for _y in range(clamp(y-brush_half_h, 0, H-1), int(clamp(y+brush_half_h, 0, H-1))):
        for _x in range(clamp(x-brush_half_w, 0, W-1), int(clamp(x+brush_half_w, 0, W-1))):
            if selection.active and selection.matrix[int(_x)][int(_y)]:
                current_layer.ctx.fillRect(int(_x), int(_y), 1, 1);

var a = 0

def lerp(a, b, t):
    return ((1-t)*a) + (t*b)


def draw_brush_image(brush_canvas, x, y):
    img_data = current_layer.ctx.getImageData(x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
    brush_data = brush_canvas.getContext("2d", {willReadFrequently: true}).getImageData(0, 0, brush_size[0], brush_size[1])

    if not ERASING:
        # draw under
        if held_keys['u']:
            current_layer.ctx.globalCompositeOperation = "destination-over"
        # draw inside
        elif held_keys['i']:
            current_layer.ctx.globalCompositeOperation = "source-atop"
        # draw normally
        else:
            current_layer.ctx.globalCompositeOperation = "source-over"
    # erase
    else:
        current_layer.ctx.globalCompositeOperation = "destination-out"

    brush_scaling_canvas.width = brush_data.width
    brush_scaling_canvas.height = brush_data.height
    brush_scaling_ctx.putImageData(brush_data, 0, 0)
    current_layer.ctx.drawImage(brush_scaling_canvas, x-(brush_size[0]/2), y-(brush_size[1]/2), brush_size[0], brush_size[1])
    return
        # print('draw')
        # if REPLACE:
        #     current_layer.ctx.globalCompositeOperation="destination-atop";
        # if a replace color is set, only fill area with a similar color
        # else:
        #     print('replace')
        #     brush_half_w = brush_size[0] / 2
        #     brush_half_h = brush_size[1] / 2
        #     current_layer.ctx.fillStyle = 'cyan'

            # for _y in range(clamp(y-brush_half_h, 0, H-1), int(clamp(y+brush_half_h, 0, H-1))):
            #     for _x in range(clamp(x-brush_half_w, 0, W-1), int(clamp(x+brush_half_w, 0, W-1))):
            #         current_pixel_color = current_layer.ctx.getImageData(_x, _y, 1, 1).data
            #         # continue
            #         print(current_pixel_color, current_color)
            #         if current_pixel_color[3] > 0:
            #         # if current_pixel_color[0] == current_color[0] and current_pixel_color[1] == current_color[1] and current_pixel_color[2] == current_color[2]:
            #             current_layer.ctx.fillRect(int(_x), int(_y), 1, 1);


def sample_color(position=None):
    # combined_sample = canvas_entity.color
    combined_sample = [0,0,0,0]
    for layer in layers:
        if not position:
            pos = get_canvas_position(layer)
        else:
            pos = position
        sampled_color = layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
        for i in range(4):
            combined_sample[i] = lerp(combined_sample[i], sampled_color[i], sampled_color[3]/255)

    ERASING = combined_sample[3] == 0
    combined_sample[3] = 255

    if current_brush.painterly_brush: # make the color a bit brighter when using painterly_brush since it paints a bit darker than the selected color
        combined_sample[0] += 16
        combined_sample[1] += 16
        combined_sample[2] += 16

    return combined_sample


def paint():
    if not current_layer or not current_layer.enabled:
        return

    if held_keys['alt'] and held_keys['control']: # sample current layer
        pos = get_canvas_position()
        sampled_color = current_layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
        for i in range(3):
            sampled_color[i] = lerp(canvas_entity.color[i], sampled_color[i], sampled_color[3]/255)

        sampled_color[3] = 255

        set_color(sampled_color)
        return

    # sample combined
    if (held_keys['alt'] and not held_keys['control']):
        sampled_color = sample_color()
        set_color(sampled_color)
        return

    if mouse.hovered_entity != bg:
        return

    if held_keys['space']:
        return

    [x, y] = get_canvas_position()

    if current_brush['min_pressure'] < 1:
        update_brush_tip(current_color)

    if held_keys['w'] and prev_pos:
        x = lerp(prev_pos[0], x, .025)
        y = lerp(prev_pos[1], y, .025)


    if prev_pos == None:
        if held_keys['g']:
            set_color(sample_color(get_canvas_position()))
            update_brush_tip(current_color)

        if draw_on_click:
            random_radian = random.randint(0, 360) * Math.PI / 180
            after .1:
                stamp(x, y, random_radian)

        start_position = [x,y]
        prev_draw_pos = pos
        prev_pos = [x,y]
        pixels_traveled = 0
        return

    if snap_to_hex:
        y = start_position[1] + (x-start_position[0])

    if held_keys['shift']:
        velocity = [x-start_position[0], y-start_position[1]]
        if abs(velocity[0]) > abs(velocity[1]):
            y = prev_pos[1]
        else:
            x = prev_pos[0]

    distance_since_last_frame = distanceApprox(prev_pos, [x,y])
    pixels_traveled += distance_since_last_frame
    spacing_in_pixels = brush_size[1]*SPACING
    steps = floor(pixels_traveled / spacing_in_pixels)

    delta_pos = [x - prev_pos[0], y - prev_pos[1]]
    radians = -math.atan2(delta_pos[0], delta_pos[1])

    if steps > 0 and held_keys['n']:
        update_brush_tip(sample_color([x,y]))


    for i in range(0, steps):
        t = i / steps
        let _x = lerp(prev_pos[0], x, t)
        let _y = lerp(prev_pos[1], y, t)

        stamp(_x, _y, radians)
        prev_draw_pos = [_x, _y]

    pixels_traveled -= steps * spacing_in_pixels
    prev_pos = [x, y]
    # prev_pos_for_line_draw_mode = [x, y]
    # if not held_keys['shift']:

def stamp(_x, _y, radians=0):
    if brush_tips:
        prev_brush_tip += 1
        if prev_brush_tip >= brush_tips.length:
            prev_brush_tip = 0

    if not current_brush.rotate:
        if brush_tips:
            draw_brush_image(brush_canvases[prev_brush_tip], _x, _y)
        elif current_brush.shape == 'rect':
            draw_rect(_x, _y)
        elif current_brush.shape == 'circle':
            draw_circle(_x, _y)

    elif current_brush.rotate == True:
        # if brush_tips:
            # IMG.src = brush_canvases[prev_brush_tip].toDataURL()
        invoke(def anon():
            current_layer.ctx.translate(_x, _y)
            current_layer.ctx.rotate(radians)
            draw_brush_image(brush_canvases[prev_brush_tip], 0, 0)
            current_layer.ctx.rotate(-radians)
            current_layer.ctx.translate(-_x, -_y)
        , delay=0)

    elif current_brush.rotate == 'random':
        # if brush_tips:
            # IMG.src = brush_canvases[prev_brush_tip].toDataURL()
        invoke(def anon():
            random_radian = random.randint(0, 360) * Math.PI / 180
            current_layer.ctx.translate(_x, _y)
            current_layer.ctx.rotate(random_radian)
            # current_layer.ctx.drawImage(IMG, -brush_size[0]/2, -brush_size[1]/2)
            draw_brush_image(brush_canvases[prev_brush_tip], 0, 0)

            current_layer.ctx.rotate(-random_radian)
            current_layer.ctx.translate(-_x, -_y)
        , delay=0)

# Approximation by using octagons approach
def distanceApprox(p1,p2):
    var x = p2[0]-p1[0]
    var y = p2[1]-p1[1]
    return 1.426776695*Math.min(0.7071067812*(Math.abs(x)+Math.abs(y)), Math.max(Math.abs(x), Math.abs(y)))

opacity_keys = '|1234567890'.split('')
target_zoom = bg.scale_y
zoom_label = *Button(text='100%', scale=[.1,.025], origin=[.5,-.5], y=-.495, text_color=hsv(0,0,.5), text_size=1.5, on_click=def():target_zoom=1, x=lerp(left_button_x, right_button_x, .5))
zoom_label.update = def zoom_label_update():
    bg.scale_x = lerp(bg.scale[0], target_zoom*canvas_aspect, .2)
    bg.scale_y = lerp(bg.scale[1], target_zoom, .2)

def input(key):
    # print(key)
    for i, e in enumerate(opacity_keys):
        if key == e:
            if current_tool == brush_tool:
                if not SMUDGE:
                    current_color[3] = int(255/10 * i)
                    # print(current_color)
                else:
                    SMUDGE_STRENGTH = int(i) / 10
                    if i == 0:
                        SMUDGE_STRENGTH = 1
                    print(SMUDGE_STRENGTH)
    if (held_keys['control'] and key == 'z'):
        undo()

    # if held_keys['control'] and key == 'y':
    if key == 'y':
        redo()

    # if key == 'a':
    #     for y in range(H/2):
    #         for x in range(W/2):
    #             selection['matrix'][x][y] = True
    #     render_selection()

    if held_keys['control'] and key == 'c':
        if selection.active:
            copied_image_data = copy_selection()
            # data = Uint8ClampedArray.from(image_data.data)
            data = Uint8ClampedArray.from(copied_image_data.data)
            navigator.clipboard.writeText(`local_image:${JSON.stringify([data, selection.bounds[0], selection.bounds[1], selection.bounds[2]-selection.bounds[0], selection.bounds[3]-selection.bounds[1]])}`)
        else:
            # copied_image_data = copy_all()

            current_layer.canvas.toBlob(function(blob) {
                const item = new ClipboardItem({ "image/png": blob });
                navigator.clipboard.write([item]);
            });


    if key in ['s','gamepad y']:
        new_size = [clamp(int(e*2), 1, 2048) for e in brush_size]
        set_brush_size(new_size)

    if key in ['x','gamepad x']:
        new_size = [clamp(int(e/2), 1, 2048) for e in brush_size]
        set_brush_size(new_size)

    # if key == 'h':
    #     selection_canvas_entity.enabled = not selection_canvas_entity.enabled
        # snap_to_hex = True
    if key == 'scroll down' or (held_keys['control'] and key == 'down arrow'):
        target_zoom = target_zoom*.9
        zoom_label.text = `${int(target_zoom*100)}%`
    if key == 'scroll up' or (held_keys['control'] and key == 'up arrow'):
        target_zoom = target_zoom*1/.9
        zoom_label.text = `${int(target_zoom*100)}%`

    if key == 'middle mouse down' or key == 'space':
        bg.lock_x = False
        bg.lock_y = False
        bg.start_offset = [mouse.x-bg.x , mouse.y-bg.y]
        bg.dragging = True

    if key == 'middle mouse up' or key == 'space up':
    # if key == 'middle mouse up' or key == 'h up':
        bg.lock_x = True
        bg.lock_y = True
        bg.dragging = False

    if key == 'f':
        SMUDGE = True
        print('toggle smudge:', SMUDGE)

    if not held_keys['control'] and key == 'h':
        for layer in layers:
            const img_data = flip_image_data_horizontally(layer.ctx.getImageData(0, 0, layer.canvas.width, layer.canvas.height))
            layer.ctx.putImageData(img_data, 0, 0)

    if not held_keys['control'] and key == 'v':
        for layer in layers:
            const img_data = flip_image_data_vertically(layer.ctx.getImageData(0, 0, layer.canvas.width, layer.canvas.height))
            layer.ctx.putImageData(img_data, 0, 0)

    if key == '?':
        current_color_as_hsv = rgb_to_hsv(current_color)
        # random_color = [random.randint(0,360), current_color[1], current_color[2], current_color[3]]  # this was a mistake, but creates only a small variation and could be useful to have
        random_color = hsv(random.randint(0,360), current_color_as_hsv[1], current_color_as_hsv[2], current_color_as_hsv[3])
        set_color(random_color)



def flip_image_data_horizontally(img_data):
    for (let y = 0; y < img_data.height; y++):
        for (let x = 0; x < img_data.width / 2; x++):
            const i = (y * img_data.width+x) * 4
            const j = (y * img_data.width+(img_data.width - x - 1)) * 4
            const tmp = [img_data.data[i], img_data.data[i+1], img_data.data[i+2], img_data.data[i+3],
            ]
            img_data.data[i] = img_data.data[j]
            img_data.data[i+1] = img_data.data[j+1]
            img_data.data[i+2] = img_data.data[j+2]
            img_data.data[i+3] = img_data.data[j+3]
            img_data.data[j] = tmp[0]
            img_data.data[j+1] = tmp[1]
            img_data.data[j+2] = tmp[2]
            img_data.data[j+3] = tmp[3]

    return img_data

def flip_image_data_vertically(imageData):
    const temp = new Uint8ClampedArray(imageData.data.length);

    for (let i = 0; i < imageData.height; i++):
        const srcOff = i * imageData.width * 4;
        const dstOff = (imageData.height - i - 1) * imageData.width * 4;
        temp.set(imageData.data.subarray(srcOff, srcOff + imageData.width * 4), dstOff);

    imageData.data.set(temp);

    return imageData


def update():
    if mouse.hovered_entity == bg:
        if not held_keys['alt'] and current_tool == brush_tool: # if not sampling color
            document.body.style.cursor = 'none'
        else:
            document.body.style.cursor = 'crosshair'

        if mouse.point:
            brush_cursor.xy = mouse.point
        # document.body.style.cursor = `url('${brush_canvases[0].toDataURL()}') ${brush_size[0]/2} ${brush_size[1]/2}, auto`
    else:
        document.body.style.cursor = 'auto'


    # brush_size = [e*mouse.pressure for e in brush]

color_menu = Entity(parent=camera.ui, visible_self=False, position=[left_button_x,.465,-1])
color_menu.menu = Entity(parent=color_menu, visible_self=False, enabled=1, scale=[.1,.2], enabled=True)

def color_menu_input(key):
    if key == 'w':
        lighter_color_button.on_click()
    if key == 'q':
        darker_color_button.on_click()

#     if key == 'c':
#         color_menu.menu.enabled = not color_menu.menu.enabled
color_menu.input = color_menu_input

slider_height = .075
sunsnake.define(*color_slider_style, parent=color_menu.menu, scale_y=.075, roundness=.1, draggable=True, lock_x=True, lock_y=True)
# color_menu_bg = Entity(parent=color_menu.menu, x=.15, scale=[1.05+.3, (slider_height*1.1*3)+.05], color=color.black, alpha=.8, roundness=.05, z=2, ignore_collision=False)
color_preview = Entity(parent=color_menu.menu, scale=[1, slider_height*2], y=-.25, origin=[0,0], roundness=.25)
lighter_color_button = Entity(parent=color_preview, x=.5, origin=[.5,0], scale=[.2,1], roundness=color_preview.roundness)
darker_color_button = Entity(parent=color_preview, x=-.5, origin=[-.5,0], scale=[.2,1], roundness=color_preview.roundness)

for preview in [lighter_color_button, darker_color_button]:
    let e = preview
    e.on_click = def():
        set_color(e.color)


def move_color_slider(slider):
    slider.indicator.x = mouse.point[0]
    set_color(hsv(int((hue_slider.indicator.x+.5)*360), (sat_slider.indicator.x+.5)*1, (val_slider.indicator.x+.5)*1), move_sliders=False)

hue_slider = Entity(*color_slider_style, y=slider_height*1.5, texture='rainbow.png', name='hue_slider')
hue_slider.indicator = Entity(parent=hue_slider, scale_x=.015, color=color.black, z=-2)
hue_slider.while_dragging = def():
    move_color_slider(hue_slider)
hue_slider.on_click = hue_slider.while_dragging

sat_slider = Entity(*color_slider_style, y=0)
sat_slider.overlay = Entity(parent=sat_slider, texture='horizontal_gradient.png', y=0, z=-1, roundness=.15)
sat_slider.indicator = Entity(parent=sat_slider, scale_x=.015, color=color.black, z=-2)
sat_slider.while_dragging = def():
    move_color_slider(sat_slider)
sat_slider.on_click = sat_slider.while_dragging

val_slider = Entity(*color_slider_style, y=-slider_height*1.5)
val_slider.overlay = Entity(parent=val_slider, texture='horizontal_gradient.png', color=color.black, rotation=180, y=0, z=-1, roundness=.15)
val_slider.indicator = Entity(parent=val_slider, scale_x=.015, color=color.black, z=-2)
val_slider.while_dragging = def():
    move_color_slider(val_slider)
val_slider.on_click = val_slider.while_dragging

def set_color(value, move_sliders=True):
    if len(value) == 3:
        value.append(255)

    # print('set color:', value)
    current_color = value
    color_preview.color = current_color
    color_as_hsv = rgb_to_hsv(current_color)
    color_saturated = hsv(color_as_hsv[0], 1, color_as_hsv[2])
    color_desaturated = hsv(color_as_hsv[0], 0, color_as_hsv[2])
    sat_slider.color = color_saturated
    # sat.overlay.color = rgb(color_desaturated[0]/255, color_desaturated[1]/255, color_desaturated[2]/255)
    # sat.overlay.alpha = current_color[3]/255
    hue = color_as_hsv[0] - 10
    if hue < 0:
        hue = 360 + hue
    lighter_color_button.color = hsv(hue, clamp(color_as_hsv[1]-.05,0,1), clamp(color_as_hsv[2]+.1, 0, 1))
    hue = color_as_hsv[0] + 10
    if hue < 0:
        hue = hue - 360
    darker_color_button.color = hsv(hue, color_as_hsv[1]+.05, color_as_hsv[2]-.1)

    if move_sliders:
        hue_slider.indicator.x = -.5 + color_as_hsv[0]/360
        sat_slider.indicator.x = -.5 + color_as_hsv[1]
        val_slider.indicator.x = -.5 + color_as_hsv[2]


for i, e in enumerate(brushes):
    let brush = e
    let brush_button = *Button(x=-.1, y=.295+(.055*-floor(i/2)), roundness=.01, text_size=.75, text_origin=[-.5,-.5], text=e.name.replace('_', '\n'))
    if i%2 == 0:
        brush_button.x = left_button_x
    else:
        brush_button.x = right_button_x

    if not e.textures:
        if e.shape == 'rect':
            icon = Entity(roundness=0, parent=brush_button, xy=[-.5,-.5], color=color.white, z=-1, scale=.6, alpha=.75)
        if e.shape == 'circle':
            icon = Entity(roundness=.5, parent=brush_button, xy=[-.5,-.5], color=color.white, z=-1, scale=.6, alpha=.75)
    else:
        icon = Entity(roundness=.01, parent=brush_button, xy=[-.5,-.5], color=color.black, z=-1, scale=.8, alpha=.75)
        icon.texture = `assets/${e.textures[0]}`
        icon_aspect = brush.size[0] / brush.size[1]
        if icon_aspect > 1:
            icon.scale = [.8, icon_aspect*.8]
        else:
            icon.scale = [icon_aspect*.8, .8]

    brush_button.on_click = def():
        set_brush(brush)


# eyedropper = Entity(name='eyedropper', visible_self=False)
# eyedropper.update = def eyedropper_update():
#     if mouse.left:
#         print('smaple')
#         if mouse.hovered_entity == bg:
#             pos = get_canvas_position()
#             current_color = current_layer.ctx.getImageData(pos[0], pos[1], 1, 1).data
#             set_color(current_color)
#             return
#
#         elif mouse.hovered_entity:
#             set_color(mouse.hovered_entity.color)

window.onfocus = def():
    set_current_tool(brush_tool)
    for key, value in held_keys:
        if value:
            held_keys[key] = 0


save_button = *Button(xy=[(-.5*aspect_ratio)+.06,.5], origin=[-.5,.5], scale=[.05,.025], text='save', text_size=1)
save_button.on_click = def save():
    save_file(current_layer.canvas)

save_button.input = def input(key):
    if held_keys['shift'] and key == 's':
        save_button.on_click()

save_animation_button = *Button(xy=[(-.5*aspect_ratio)+.12,.5], origin=[-.5,.5], scale=[.075,.025], text='save\nanimation', text_size=1, on_click=save_animation)

async def save_animation():
    num_frames = len(animator.frames)
    # images = []
    # for i in range(num_frames):
    #     goto_frame(i)
    #     images.append(current_layer.canvas.toDataURL('image/png'))
    const options = {
        types: [{
        description: 'png animation',
        accept: {'text/otomation': ['.otomation'],},
        },],
        suggestedName: 'untitled_animation.otomation'
    }
    data = {
        'fps' : FPS,
        'frames' : animator.frames
    }
    const jsonData = JSON.stringify(data)
    const jsonBlob = new Blob([jsonData], {type: 'application/json'})
    const newHandle = await window.showSaveFilePicker(options)
    const writableStream = await newHandle.createWritable()
    await writableStream.write(jsonBlob)
    await writableStream.close()
    # const gif = new GIF({workers: 2, quality: 1})

    # num_frames = len(animator.frames)
    # for i in range(num_frames):
    #     goto_frame(i)
    #     # number_string = `000${i}`.substr(-4)
    #     # print('save frame as:', `${DOCUMENT_NAME}_${number_string}`)
    #     # save_file(current_layer.canvas, `${DOCUMENT_NAME}_${number_string}`)
    #     gif.addFrame(current_layer.canvas, {delay: int(1/FPS*1000)})

    # # // Render the GIF and automatically download it
    # const options = {
    #     types: [{
    #         description: 'GIF Image',
    #         accept: { 'image/gif': ['.gif'] },
    #     }],
    #     suggestedName: 'untitled_animation.gif'
    # }
    # async def on_finished(blob):
    #     print('finished', blob)
    #     const newHandle = await window.showSaveFilePicker(options)
    #     const writableStream = await newHandle.createWritable()
    #     await writableStream.write(blob)
    #     await writableStream.close()

    # gif.on('finished', on_finished)

    # gif.render() # Start rendering the GIF
    # print('RENDER GIF!!!')


    # dataURL = canvas.toDataURL("image")
    # window.localStorage.setItem("image", dataURL)



def copy_selection():
    if selection.active:
        selection_x = selection.bounds[0]
        selection_y = selection.bounds[1]
        selection_width = selection.bounds[2] - selection.bounds[0]
        selection_height = selection.bounds[3] - selection.bounds[1]

        image_data = current_layer.ctx.getImageData(selection_x, selection_y, selection_width, selection_height)

        i = 0
        for y in range(selection_height):
            for x in range(selection_width):
                image_data.data[i+3] *= int(selection.matrix[selection_x+x][selection_y+y])
                i += 4

        return image_data

# def copy_all():
#     return current_layer.ctx.getImageData(0, 0, W, H)



async def paste(e):
    e.preventDefault()
    e.stopPropagation()
    paste_data = e.clipboardData.items[0]
    print('paste data', paste_data)

    if paste_data.kind == 'string':
        paste_data.getAsString(def anon(value):
            # print('paste local data', value)
            if value.startsWith('local_image:'):
                [data, _x, _y, _w, _h] = JSON.parse(value.split('local_image:')[1])
                values = []
                for key, value in data.items():
                    values.append(value)

                data = new Uint8ClampedArray(values)
                image_data = new ImageData(data, _w, _h)
                current_layer.ctx.putImageData(image_data, _x, _y)
                record_undo()
        )
        return False

    file = paste_data.getAsFile()
    if file.name == 'image.png':
        var URLObj = window.URL || window.webkitURL;
        var source = URLObj.createObjectURL(file);
        print('-----', source)
        loaded_image = new Image();
        loaded_image.onload = def on_load():
            current_layer.ctx.clearRect(0, 0, W, H)
            current_layer.ctx.drawImage(loaded_image, 0, 0)

        loaded_image.src = source
        # current_layer.ctx.drawImage(pastedImage, 0, 0)
        # after .01:
        #     current_layer.ctx.drawImage(pastedImage, 0, 0)
        record_undo()

window.addEventListener("paste", paste)


# download_button = *Button(text='download', scale=[.1,.04], origin=[.5,.5], x=(.5*aspect_ratio)-.0125, y=-.42)
# var link = document.createElement('a');
# download_button.on_click = def download():
#     link.download = "untitled.png"
#     # download_button.href = canvas.toDataURL()
#     link.href = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream")
#
#     link.click()
#     print('download')


def undo():
    if undo_index > 0:
        undo_index -= 1

    # [type, data] = undo_data[undo_index]
    # print('ddd', type, data)
    # if type == 'paint_stroke':
    #     [layer, data] = data
    #     var loaded_image = new Image
    #     loaded_image.src = data
    #     loaded_image.onload = def on_load():
    #         layer.ctx.clearRect(0, 0, W, H)
    #         layer.ctx.drawImage(loaded_image, 0, 0)

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def on_load():
        current_layer.ctx.clearRect(0, 0, W, H)
        current_layer.ctx.drawImage(loaded_image, 0, 0)

def redo()
    if undo_index < undo_data.length-1:
        undo_index += 1

    var loaded_image = new Image
    loaded_image.src = undo_data[undo_index]
    loaded_image.onload = def():
        current_layer.ctx.clearRect(0, 0, W, H)
        current_layer.ctx.drawImage(loaded_image, 0, 0)


def record_undo():
    if undo_data.length > undo_index+1:
        undo_data.splice(undo_index+1)
        # print('delete old undo data')

    undo_data.push(current_layer.canvas.toDataURL())
    # undo_data.push(['paint_stroke', [current_layer, current_layer.canvas.toDataURL()]])
    print('record undo')
    undo_index += 1

selection_matrix = Array2D(W,H,default_value=False)
selection = {'active':False, 'points':[], 'matrix':selection_matrix, 'bounds':[W,H,0,0]}

def render_selection():
    selection.active = False
    selection_ctx.clearRect(0, 0, W, H)
    selection.bounds = [W,H,0,0]
    for y in range(H):
        for x in range(W):
            if selection['matrix'][x][y]:
                selection.bounds[0] = min(x, selection.bounds[0]) # min x
                selection.bounds[2] = max(x, selection.bounds[2]) # max x
                selection.bounds[1] = min(y, selection.bounds[1]) # min y
                selection.bounds[3] = max(y, selection.bounds[3]) # max y

                selection.active = True
                if x == 0 or x == W or y == 0 or y == H:
                    continue
                # selection_ctx.fillRect(x, y, 1, 1);

                if not selection['matrix'][x-1][y] or not selection['matrix'][x+1][y] or not selection['matrix'][x][y-1] or not selection['matrix'][x][y+1]:
                    if x % 2 == 0:
                        selection_ctx.fillStyle = 'cyan'
                    else:
                        selection_ctx.fillStyle = 'violet'

                    selection_ctx.fillRect(x, y, 1, 1);
    # print('selection bounds', selection.bounds)

lasso_tool = Entity(enabled=False, visible_self=False)
lasso_tool.input = def lasso_tool_input(key):
    if key == 'left mouse down' and mouse.hovered_entity == bg:
        pos = get_canvas_position()
        lasso_prev_pos = pos
        selection.points = []
        if not held_keys['shift'] and not held_keys['alt']:
            selection.matrix = Array2D(W,H)
            render_selection()
            # print('clear selection')
        lasso_tool.start_point = pos


    elif key == 'left mouse up':
        # print('END SELECTION')
        start = lasso_tool.start_point
        end = selection.points[len(selection.points)-1]
        if not start or not end:
            return
        dist = distance(start, end)
        if not dist:
            return

        for i in range(0, dist):
            t = i / dist
            let _x = int(lerp(start[0], end[0], t))
            let _y = int(lerp(start[1], end[1], t))
            if _x < 0 or _y < 0 or _x > W-1 or _y > H-1:
                continue

            if not [_x,_y] in selection.points:
                selection.points.append([_x,_y])
                selection.matrix[_x][_y] = not held_keys['alt']

        unique_selection = []

        for a in selection.points:
            is_duplicate = False
            for b in unique_selection: # if a in unique_selection: contine
                if a[0]===b[0] and a[1]===b[1]:
                    is_duplicate = True
                    break

            if is_duplicate:
                continue

            unique_selection.append(a)
        selection.points = unique_selection

        xs = [e[0] for e in selection.points]
        ys = [e[1] for e in selection.points]

        selection.min_x = min(...xs)
        selection.max_x = max(...xs)
        selection.min_y = min(...ys)
        selection.max_y = max(...ys)
        # #
        # selection.width = (selection.max_x - selection.min_x) +1
        # selection.height = (selection.max_y - selection.min_y) +1



        poly = selection.points
        clean_poly = [poly[0], ]
        for i in range(0, len(poly), 10):
            if distance(clean_poly[-1], poly[i]) > 32:
                clean_poly.append(poly[i])
        poly = clean_poly

        for y in range(selection.min_y, selection.max_y):
            for x in range(selection.min_x, selection.max_x):
                if inside([x,y], poly):
                    selection.matrix[x][y] = not held_keys['alt']

                # selection.matrix[x][y] = not held_keys['alt'] * inside([x,y], poly)
                    # selection.active = True

        lasso_prev_pos = None
        render_selection()

def inside(point, poly):
    # // ray-casting algorithm based on
    # // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html
    var x = point[0], y = point[1]
    var inside = False

    for (var i=0, j=poly.length-1; i < poly.length; j=i++):
        var xi = poly[i][0], yi = poly[i][1];
        var xj = poly[j][0], yj = poly[j][1];

        intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
        if intersect:
            inside = !inside;

    return inside

def get_pixel(x, y):
    return current_layer.ctx.getImageData(x, y, 1, 1).data
def set_pixel(x, y, color):
    # current_layer.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`
    current_layer.ctx.fillRect(x, y, 1, 1);

# paint_bucket = Entity(visible_self=False)
# margin = 3
# pixel_grid = None
# paint_bucket.input = def paint_bucket_input(key):
#     if key == 'g' and mouse.hovered_entity == bg:
#         current_layer.ctx.fillStyle = `rgba(${current_color[0]}, ${current_color[1]}, ${current_color[2]}, ${current_color[3]})`
#
#         if held_keys['shift']:
#             print('fill')
#             pixel_grid = Array2D(W, H)
#             for _y in range(H):
#                 for _x in range(W):
#                     pixel_grid[_x][_y] = get_pixel(_x, _y)
#
#             [x, y] = get_canvas_position()
#             floodfill(x, y)
#
#         else:
#             [x, y] = get_canvas_position()
#             color_to_replace = get_pixel(x, y)
#             for y in range(H):
#                 for x in range(W):
#                     pixel = get_pixel(x, y)
#                     if abs(pixel[0]-color_to_replace[0]) <= margin and abs(pixel[1]-color_to_replace[1]) <= margin and abs(pixel[2]-color_to_replace[2]) <= margin:
#                         current_layer.ctx.fillRect(x, y, 1, 1);
#
# fill_stack = []
# def floodfill(x, y):
#     fill_stack.push([x, y])
#     color_to_replace = pixel_grid[x][y]
#
#     while (fill_stack.length > 0):
#         # if held_keys['escape']:
#         #     break
#
#         var [x, y] = fill_stack.pop();
#
#         if x < 0 or x >= W or y < 0 or y >= H:
#             continue
#
#         pixel = pixel_grid[x][y]
#         if abs(pixel[0]-color_to_replace[0]) > margin or abs(pixel[1]-color_to_replace[1]) > margin or abs(pixel[2]-color_to_replace[2]) > margin:
#             continue
#
#         pixel_grid[x][y] = current_color
#         set_pixel(x, y, current_color)
#
#         fill_stack.push([x + 1, y]);
#         fill_stack.push([x - 1, y]);
#         fill_stack.push([x, y + 1]);
#         fill_stack.push([x, y - 1]);


lasso_prev_pos = None

lasso_tool.update = def():
    if not mouse.left:
        return

    pos = get_canvas_position()
    dist = distanceApprox(lasso_prev_pos, pos)
    if not dist:
        return

    for i in range(0, dist):
        t = i / dist
        let _x = int(lerp(lasso_prev_pos[0], pos[0], t))
        let _y = int(lerp(lasso_prev_pos[1], pos[1], t))

        if _x < 0 or _y < 0 or _x > W-1 or _y > H-1:
            continue

        if not [_x,_y] in selection.points:
            selection.points.append([_x,_y])
            selection.matrix[_x][_y] = not held_keys['alt']
            if _x % 2 == 0:
                selection_ctx.fillStyle = 'pink'
                selection_ctx.fillRect(_x, _y, 1, 1);
            # else:
            #     selection_ctx.fillStyle = 'magenta'

    lasso_prev_pos = pos
    # if not [x,y] in selection:
    #     selection.append([x,y])
    #     ctx.fillStyle = rgb(0/255, 0/255, 0/255, 255/255)
    #     ctx.fillRect(x, y, 2, 2);

rect_select_tool = Entity(name='rect_select_tool', visible_self=False, enabled=False)
rect_select_tool.input = def rect_select_tool_input(key):
    if key == 'left mouse down':
        self.start_pos = get_canvas_position()
        if not held_keys['shift'] and not held_keys['alt']:
            selection.points = []
            selection.matrix = Array2D(W,H)
            # print('clear selection')

    if key == 'left mouse up' and self.start_pos:
        self.end_pos = get_canvas_position()
        start_y = min(self.start_pos[1], self.end_pos[1])
        end_y =  max(self.start_pos[1], self.end_pos[1])
        start_x = min(self.start_pos[0], self.end_pos[0])
        end_x =  max(self.start_pos[0], self.end_pos[0])
        start_y = clamp(start_y, 0, H-1)
        end_y = clamp(end_y, 0, H-1)
        start_x = clamp(start_x, 0, W-1)
        end_x = clamp(end_x, 0, W-1)

        for y in range(start_y, end_y):
            for x in range(start_x, end_x):
                selection.matrix[x][y] = not held_keys['alt']

        render_selection()

transform_tool = Entity(parent=canvas_entity, visible_self=False, enabled=False, draggable=True)

transform_tool.input = def transform_tool_input(key):
    if key == 'left mouse down' and not held_keys['control'] and not held_keys['shift'] and not held_keys['alt']:
        transform_tool.xyz = current_layer.xyz
        current_layer.parent = transform_tool
        current_layer.xy = [0,0]
    elif key == 'left mouse up':
        current_layer.parent = canvas_entity
        current_layer.xy = transform_tool.xy
        # current_layer.scale = current_layer.scale

        # current_layer.dragging = False
        # current_layer.draggable = False
# current_layer.draggable=True

tools = [brush_tool, lasso_tool, rect_select_tool, transform_tool]

current_tool = None
def set_current_tool(tool):
    prev_tool = current_tool
    current_tool = tool
    for e in tools:
        if e != tool:
            e.enabled = False
        else:
            e.enabled = True

set_current_tool(brush_tool)

tool_toggler = Entity(visible_self=False)
tool_toggler.input = def tool_toggler_input(key):
    combined_key = get_combined_key(key)
    if combined_key in ['b',]:
        set_current_tool(brush_tool)
        SMUDGE = False
        ERASING = False
    # elif key == 'alt' and current_tool == brush_tool:
    #     set_current_tool(eyedropper)
    # elif key == 'alt up' and current_tool == eyedropper:
    #     set_current_tool(brush_tool)
    elif combined_key == 'e':
        ERASING = True
        set_current_tool(brush_tool)

    elif combined_key in ['l','p']:
        set_current_tool(lasso_tool)
    elif combined_key == 'm':
        set_current_tool(rect_select_tool)
    elif combined_key == 'v':
        set_current_tool(transform_tool)

file_handler = Entity(visible_self=False)
file_handler.input = def file_handler_input(key):
    if key == 'o':
        open_file()

async def open_file():
    const pickerOpts = {types: [{description: "Images", accept:{"image/*": [".png", ".gif", ".jpeg", ".jpg", ".otomation"],},},], excludeAcceptAllOption: true, multiple: false};
    const [fileHandle] = await window.showOpenFilePicker(pickerOpts)
    const file = await fileHandle.getFile()
    const reader = new FileReader();

    # print('fffffffffffffffff', file)
    if file['name'].endswith('.otomation'):
        # load_animation()
        print('load animation')
        reader.onload = def on_load(event):
            const data = JSON.parse(event.target.result)
            FPS = data['fps']
            animator.frames = data['frames']
            print('loaded animation')


        reader.readAsText(file)
        return

    _IMG = new Image()

    reader.addEventListener('load', (event) => :
        _IMG.onload = def():
            new_document(this.width, this.height)
            current_layer.ctx.drawImage(_IMG,0,0)
            record_undo()

        _IMG.src = event.target.result;
    )
    reader.readAsDataURL(file);


async def save_file(canvas, suggested_name='untitled.png'):
    const options = {
    types: [{
      description: 'png transparent',
      accept: {'image/png': ['.png'],},
    },
    {
      description: 'png opaque',
      accept: {'image/png': ['.png'],},
    }
    ],
    suggestedName: suggested_name
    }
    const newHandle = await window.showSaveFilePicker(options)
    const writableStream = await newHandle.createWritable()

    imgBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    await writableStream.write(imgBlob)
    await writableStream.close()


document.ondrop = def ondrop(event):
    event.preventDefault()
    files = [e for e in event.dataTransfer.files]
    if not files:
        return False


    let reader = new FileReader()
    reader.onloadend = def():
        img = new Image()
        img.src = reader.result
        img.onload = def():
            # print('aaaaaaaaaaaaaaa', img)
            new_document(img.width, img.height)
            current_layer.ctx.drawImage(img, 0, 0)
            record_undo()
    reader.readAsDataURL(files[0])


document.ondragover = def ondragover(event):
    event.preventDefault()

window.onbeforeunload = def():
    if not held_keys['shift']:
        return "Data will be lost if you leave the page, are you sure?"


new_document(1920, 1080)
set_layer(first_layer)

if '?' in window.location.href:
    args = window.local_image.href.split('?',1)[1]
    print('---------------', args)


class RadialMenu extends Entity:
    constructor(kwargs):
        let settings = dict(parent=camera.ui, visible_self=False, active=False, shortcut=None)
        for key, value in kwargs.items():
            settings[key] = value

        super(settings)
        this.buttons = settings['buttons']
        this.menu = Entity(parent=this, visible_self=False, enabled=settings['active'])
        this._center_indicator = Entity(parent=this.menu, scale=.05, color=color.azure, shadow=True, alpha=.5, roundness=.5)
        this.line = Entity(parent=this.menu, scale=[.5, .005], origin=[-.5,0], color=color.azure, z=-2, roundness=.5)
        this.bg = Entity(parent=this.menu, z=0, color=color.black, alpha=.25, scale=10)
        this.selected_button = None
        for i, b in enumerate(this.buttons):
            b.parent = this.menu
            let angle = (Math.PI/2) -(i / (len(this.buttons)/2)) * Math.PI
            b.x = (.15 * Math.cos(angle))
            b.y = (.15 * Math.sin(angle))

    update():
        this.line.scale_x = distance(this.menu.xy, mouse.position)
        this.line.look_at([mouse.position[0]-this.menu.x, mouse.position[1]-this.menu.y])

        if distance(this.menu.xy, mouse.position) < .1:
            this.selected_button = None
            for e in this.buttons:
                e.color = color.black
            return

        let angle = this.line.rotation + 90 + (180/len(this.buttons))
        if angle < 0:
            angle = 360 + angle

        this.selected_button = this.buttons[int(angle / 360 * len(this.buttons))]

        for e in this.buttons:
            e.color = color.black
        this.selected_button.color = color.azure

    input(key):
        if key == this.shortcut:
            this.menu.xy = mouse.position
            this.menu.enabled = True
        elif key == this.shortcut + ' up':
            this.menu.enabled = False
            if this.selected_button:
                this.selected_button.on_click()


sunsnake.define(*ShortcutMenuButton(,Button(roundness=.5, scale=.1, color=color.black, text_color=color.white, alpha=.75, text_size=1.5, ignore_collision=False, )
save_selected_button = *ShortcutMenuButton(text='download \nselection')
canvas_for_saving = document.createElement('canvas');

save_selected_button.on_click = def():
    if not selection.active:
        return
    image_data = copy_selection()

    canvas_for_saving.width = image_data.width
    canvas_for_saving.height = image_data.height
    canvas_for_saving.getContext('2d').clearRect(0, 0, image_data.width, image_data.height)
    canvas_for_saving.getContext('2d').putImageData(image_data, 0, 0)
    save_file(canvas_for_saving)


select_layer_above_button = *ShortcutMenuButton(text='select layer \nabove')
select_layer_above_button.on_click = def():
    current_layer_index = clamp(layers.index(current_layer)+1, 0, len(layers)-1)
    set_layer(layers[current_layer_index])

select_layer_below_button = *ShortcutMenuButton(text='select layer \nbelow')
select_layer_below_button.on_click = def():
    current_layer_index = clamp(layers.index(current_layer)-1, 0, len(layers)-1)
    set_layer(layers[current_layer_index])

empty = *ShortcutMenuButton(text='---')
_save_button = *ShortcutMenuButton(text='save')
_SW = *ShortcutMenuButton(text='lasso', on_click=def():set_current_tool(lasso_tool))
_W = *ShortcutMenuButton(text='brush', on_click=def():set_current_tool(brush_tool); ERASING=False)
_NW = *ShortcutMenuButton(text='erase', on_click=def():set_current_tool(brush_tool); ERASING=True)


_buttons = [
    select_layer_above_button,
    empty,
    _save_button,
    save_selected_button,
    select_layer_below_button,
    _SW,
    _W,
    _NW,
    ]

radial_menu = RadialMenu(buttons=_buttons, shortcut='q')
Entity(visible_self=False).input = def input(key):
    if key == 'right mouse down' and not held_keys['control']:
        radial_menu.input(radial_menu.shortcut)
    if key == 'right mouse up':
        radial_menu.input(radial_menu.shortcut + ' up')


paint_filter = Entity(visible_self=False)
paint_filter.input = def paint_filter_input(key):
    if held_keys['control'] and held_keys['shift'] and key == 'f':
        paint_filter.apply_paint_filter()

paint_filter.apply_paint_filter = def():
    h_res = 16
    w_res = floor(h_res * canvas_aspect)

    brush_aspect = current_brush.size[0] / current_brush.size[1]
    print(brush_aspect)
    set_brush_size([H/h_res, H/h_res/brush_aspect])

    for _x in range(w_res):
        for _y in range(h_res):
            x = (_x+.5) / w_res * W
            y = (_y+.5) / h_res * H
            col = sample_color([x, y])
            # update_brush_tip(sample_color([x,y]))
            update_brush_tip(col)
            random_radian = random.randint(0, 360) * Math.PI / 180
            stamp(x, y, random_radian)


# hsv_menu_handler = Entity(visible_self=False)
# hsv_menu_handler.input = def input(key):
#     if key == 'u':
#         hsv_menu.enabled = not hsv_menu.enabled

# hsv_menu = Entity(scale=[.25*2,.125*2], enabled=False, roundness=.05, shadow=True, parent=camera.ui, color=color.black, alpha=.8, text_origin=[0,.5], text='HSV', text_color=color.light_gray, text_size=2, ignore_collision=False)
# hsv_menu.on_enable = def():
#     hsv_menu.original_data = current_layer.ctx.getImageData(0, 0, W, H).data
#     print('get fresh')

# hsv_menu.close = def():
#     hsv_menu.enabled = False
#     hsv_menu.hue_slider.value = 180
#     hsv_menu.sat_slider.value = 50
#     hsv_menu.val_slider.value = 50

#     if hsv_menu.original_data:
#         current_layer.ctx.putImageData(new ImageData(hsv_menu.original_data, W, H), 0, 0)
#         print('reset')

# hsv_menu.apply_button = Button(parent=hsv_menu, text='Apply', color=color.pink, text_color=color.white, scale=[.4,.15], x=.025, y=-.35, text_size=2, roundness=.5, origin=[-.5,0])
# hsv_menu.apply_button.on_click = def():
#     hsv_menu.enabled = False
#     record_undo()

# hsv_menu.discard_button = Button(parent=hsv_menu, text='Discard', color=color.gray, text_color=color.white, scale=[.4,.15], x=-.025, y=-.35, text_size=2, roundness=.5, origin=[.5,0], on_click=hsv_menu.close)
# hsv_menu.close_button = Entity(parent=hsv_menu, text='x', scale=[.05,.1], color=color.red, text_color=color.white, text_origin=[0,0], text_size=2, roundness=.5, xy=[.5,.5], origin=[.5,0], on_click=hsv_menu.close)
# hsv_menu.bg = Entity(parent=hsv_menu, visible_self=False, scale=10, on_click=hsv_menu.close, z=1)
# hsv_menu.hue_slider = RainbowSlider(parent=hsv_menu, min=0, max=360, default=180, prev_value=180, y=.3)
# hsv_menu.sat_slider = RainbowSlider(parent=hsv_menu, min=0, max=100, default=50, prev_value=50, y=.15)
# hsv_menu.val_slider = RainbowSlider(parent=hsv_menu, min=0, max=100, default=50, prev_value=50, y=0)
# hsv_menu.colorize_toggle_parent = Button(parent=hsv_menu, scale=[.1,.1], roundness=.1, text_origin=[-.5,0], text=' Colorize:', value=False, xy=[-.325,-.15], origin=[0,0], text_size=1, text_color=color.white, color=color.clear)
# hsv_menu.colorize_toggle = Button(parent=hsv_menu.colorize_toggle_parent, scale=[.5,1], roundness=.1, text_origin=[0,0], text=' ', value=False, xy=[.5,0], origin=[-.5,0], text_size=2, color=color.dark_gray, text_color=color.white)
# hsv_menu.colorize_toggle.on_click = def():
#     hsv_menu.colorize_toggle.value = not hsv_menu.colorize_toggle.value
#     hsv_menu.colorize_toggle.text = [' ', 'âœ“'][int(hsv_menu.colorize_toggle.value)]
#     apply_hsv_filter()

# def apply_hsv_filter():
#     if not hsv_menu.colorize_toggle.value:
#         apply_relative_hsv_adjustment(hsv_menu.hue_slider.value - 180, (hsv_menu.sat_slider.value-50)/100, (hsv_menu.val_slider.value-50)/100)
#     else:
#         apply_absolute_hsv_adjustment(hsv_menu.hue_slider.value, hsv_menu.sat_slider.value/100, hsv_menu.val_slider.value/100)


# hsv_menu.hue_slider.on_value_changed = apply_hsv_filter
# hsv_menu.sat_slider.on_value_changed = apply_hsv_filter
# hsv_menu.val_slider.on_value_changed = apply_hsv_filter


def apply_relative_hsv_adjustment(hue, sat, val):
    new_data = new Uint8ClampedArray(hsv_menu.original_data);

    for i in range(0, len(new_data), 4)
        _color_as_hsv = rgb_to_hsv([new_data[i], new_data[i+1], new_data[i+2]])
        _color_as_hsv = [_color_as_hsv[0]+hue, _color_as_hsv[1]+sat, _color_as_hsv[2]+val]
        if _color_as_hsv[0] < 0:
            _color_as_hsv[0] = 360 + _color_as_hsv[0]
        if _color_as_hsv[0] > 360:
            _color_as_hsv[0] = _color_as_hsv[0] - 360

        _rgb_color = hsv(_color_as_hsv[0], _color_as_hsv[1], _color_as_hsv[2])
        new_data[i] = _rgb_color[0]
        new_data[i+1] = _rgb_color[1]
        new_data[i+2] = _rgb_color[2]

    new_image_data = new ImageData(new_data, W, H)
    current_layer.ctx.putImageData(new_image_data, 0, 0)


def apply_absolute_hsv_adjustment(hue, sat, val):
    new_data = new Uint8ClampedArray(hsv_menu.original_data);
    _rgb_color = hsv(hue, sat, val)

    for i in range(0, len(new_data), 4)
        new_data[i] = _rgb_color[0]
        new_data[i+1] = _rgb_color[1]
        new_data[i+2] = _rgb_color[2]

    new_image_data = new ImageData(new_data, W, H)
    current_layer.ctx.putImageData(new_image_data, 0, 0)

set_color(current_color)

color_history = Entity(parent=menu_parent, position=right, y=.37, scale=.02, color=color.magenta, visible_self=False, i=0)
for i in range(5):
    let b = Entity(parent=color_history, scale=.9, x=-.75-i, roundness=.2, color=color.clear)
    b.on_click = def():
        set_color(b.color)
color_history.input = def input(key):
    if key == 'left mouse up' and not held_keys['alt'] and mouse.hovered_entity == bg:
        color_history.i += 1
        color_history.i = color_history.i = color_history.i % len(color_history.children)

        color_history.children[color_history.i].color = current_color

color_replacer = Entity(parent=camera.ui, scale=.05, roundness=.25, color=color.lime, origin=[-.5,0], position=window.left, text='replace:', text_size=1, text_origin=[0,.5])
color_replacer.gizmo = Entity(scale=[.05,.05], text='replace\ncolor', text_size=1, color=color.lime, text_color=color.white, origin=[-.5,-.5], roundness=.25, text_origin=[0,0], enabled=False)

# color_replacer_handler = Entity(visible_self=False)
# color_replacer_handler.input = def(key):
#     if held_keys['shift'] and key == 'r':
#         color_replacer.enabled = not color_replacer.enabled

color_replacer.update = def update():
    if held_keys['r']:
        color_replacer.gizmo.enabled = True
        color_replacer.gizmo.text = 'replace\ncolor'
        color_replacer.gizmo.position = mouse.position
        # print(get_canvas_position())
        pos = get_canvas_position()
        if pos[0] >= 0 and pos[1] >= 0 and pos[0] < W and pos[1] <  H:
            REPLACE = sample_color()
            color_replacer.gizmo.color = REPLACE
            color_replacer.color = REPLACE
            current_layer.ctx.globalCompositeOperation = 'source-atop'
        else:
            color_replacer.gizmo.text = 'exit\nreplace\ncolor'
            REPLACE = False
            color_replacer.color = color.clear
            current_layer.ctx.globalCompositeOperation = 'source-over'

    else:
        color_replacer.gizmo.enabled = False


# set_color(color.red)

# add_layer()
# add_layer()
animator = Entity(visible_self=False, i=0, frames=[], playing=False)
frame_counter = *Button(origin=[-.5,-.5], position=[bottom_left[0]+resolution_info.scale_x, bottom_left[1]], scale=[.075,.015], text='frame: 0', roundness=0, alpha=.5, text_size=1)
animator.max_frames = 3
FPS = 12


animator.frames.append(current_layer.canvas.toDataURL())
animator.input = def input(key):
    combined_key = input_handler.get_combined_key(key)

    if combined_key == 'right arrow' or combined_key == 'd':
        goto_frame(animator.i+1, True)

    elif combined_key == 'left arrow' or combined_key == 'a':
        goto_frame(animator.i-1)

    elif combined_key == 'shift+p':
        animator.i = 0
        animator.playing = not animator.playing
        print('playing', animator.playing)
        play()

    if combined_key == '+':
        add_frame()

    if combined_key == 'delete':
        pass


def add_frame():
    print('add frame')
    animator.frames[animator.i] = current_layer.canvas.toDataURL()
    current_layer.ctx.clearRect(0, 0, W, H)
    # animator
    animator.frames.append(current_layer.canvas.toDataURL())
    goto_frame(animator.i+1)

def play():
    if not animator.playing:
        return

    # print('----', animator.i)
    goto_frame(animator.i+1)
    after 1/FPS:
        # print('next frame')
        play()


def goto_frame(to_frame, save_previous_frame=True):
    print('frame:', animator.i, to_frame)
    if save_previous_frame:
        animator.frames[animator.i] = current_layer.canvas.toDataURL()


    if to_frame >= len(animator.frames):
        to_frame = 0
    animator.i = clamp(to_frame, 0, len(animator.frames)-1)

    # load next frame
    var loaded_image = new Image
    loaded_image.src = animator.frames[animator.i]
    loaded_image.onload = def():
        current_layer.ctx.clearRect(0, 0, W, H)
        current_layer.ctx.drawImage(loaded_image, 0, 0)

    frame_counter.text = `frame ${animator.i}/${len(animator.frames)-1}`

</script>

// <script src="https://cdn.cde.run/Joycon.min.js"></script>
//
// <script type="text/sunsnake" src="joycon_input.sunsnake"></script>

<script src="../taptapir/sunsnake_compiler.js"></script>
