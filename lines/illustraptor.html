<html><title>illustraptor</title><body>
<script src="../taptapir/taptapir.js"></script>
<script type='text/sunsnake'>

set_orientation('horizontal')
set_background_color("#111")
set_window_color("#222")
# set_scale(.8)

shapes = []
selection = []
camera.target_fov = 1
# bg = Entity(visible_self=False, alpha=.1, draggable=True, lock_x=True, lock_y=True, min_x=-5, max_x=5, min_y=-5, max_y=5, ignore_collision=True)
# grid = Entity(parent=bg, scale=10, z=999, color='#222', name='grid', alpha=1, texture=)
# for y in range(10):
#     for x in range(10):
#         Entity(parent=bg, xy=[-.5 + x*.1, -.5 + y*.1], z=999, scale=.1, roundness=.05, color=random_color(), alpha=.1)


gizmo = Entity(enabled=False, visible_self=False, z=-100)
sunsnake.define(SideGizmo(, Entity(parent=gizmo, color=color.azure, alpha=.3, original_color=color.azure, draggable=True, while_dragging=update_scale, )
sunsnake.define(CornerGizmo(, Entity(parent=gizmo, scale=.015, color=hsv(180,.5,.8), alpha=.3, original_color=hsv(180,.5,.8), draggable=True, roundness=.5, )
gizmo.left =  SideGizmo(scale_x=.01, lock_y=True)
gizmo.right = SideGizmo(scale_x=.01, lock_y=True)
gizmo.top =   SideGizmo(scale_y=.01, lock_x=True)
gizmo.bot =   SideGizmo(scale_y=.01, lock_x=True)

gizmo.top_right = CornerGizmo(while_dragging=def():update_scale('/'))
gizmo.bot_left = CornerGizmo(while_dragging=def():update_scale('/'))
gizmo.bot_right = CornerGizmo(while_dragging=def():update_scale('\\'))
gizmo.top_left = CornerGizmo(while_dragging=def():update_scale('\\'))

gizmos = [gizmo.left, gizmo.right, gizmo.top, gizmo.bot, gizmo.top_right, gizmo.top_left, gizmo.bot_right, gizmo.bot_left]

def update_gizmo():
    if not selection or len(selection) == 0 or dragger.is_placing_clone:
        gizmo.enabled = False
        return

    gizmo.enabled = True
    rect = selection[-1]
    # print('render selection gizmos')
    gizmo.left.x = rect.x - (rect.scale_x/2)
    gizmo.left.y = rect.y
    gizmo.left.scale_y = rect.scale_y

    gizmo.right.x = rect.x + (rect.scale_x/2)
    gizmo.right.y = rect.y
    gizmo.right.scale_y = rect.scale_y

    gizmo.top.y = rect.y + (rect.scale_y/2)
    gizmo.top.x = rect.x
    gizmo.top.scale_x = rect.scale_x

    gizmo.bot.y = rect.y - (rect.scale_y/2)
    gizmo.bot.x = rect.x
    gizmo.bot.scale_x = rect.scale_x

    gizmo.top_right.xy = [gizmo.right.x, gizmo.top.y]
    gizmo.top_left.xy = [gizmo.left.x, gizmo.top.y]
    gizmo.bot_right.xy = [gizmo.right.x, gizmo.bot.y]
    gizmo.bot_left.xy = [gizmo.left.x, gizmo.bot.y]

for e in gizmos:
    let giz = e
    giz.el.addEventListener('mouseenter', e => {giz.color = color.white})
    giz.el.addEventListener('mouseleave', e => {giz.color = giz.original_color})
    giz.drop = def drop():
        gizmo.enabled = True
        update_gizmo()


def update_scale(type='|'):
    gizmo.enabled = False
    if not selection:
        return

    rect = selection[-1]

    if type == '|':
        rect.x = lerp(gizmo.left.x, gizmo.right.x, .5)
        rect.y = lerp(gizmo.bot.y, gizmo.top.y, .5)
        rect.scale_x = abs(gizmo.right.x - gizmo.left.x)
        rect.scale_y = abs(gizmo.top.y - gizmo.bot.y)

    elif type == '/':
        rect.x = lerp(gizmo.bot_left.x, gizmo.top_right.x, .5)
        rect.y = lerp(gizmo.bot_left.y, gizmo.top_right.y, .5)
        rect.scale_x = abs(gizmo.top_right.x - gizmo.bot_left.x)
        rect.scale_y = abs(gizmo.top_right.y - gizmo.bot_left.y)

    elif type == '\\':
        rect.x = lerp(gizmo.top_left.x, gizmo.bot_right.x, .5)
        rect.y = lerp(gizmo.top_left.y, gizmo.bot_right.y, .5)
        rect.scale_x = abs(gizmo.bot_right.x - gizmo.top_left.x)
        rect.scale_y = abs(gizmo.top_left.y - gizmo.bot_right.y)

def add_shape(select=True):
    let rect = Entity(scale=.1, draggable=True, alpha=.4, min_x=-9999, max_x=9999, min_y=-9999, max_y=9999, while_dragging=update_gizmo)

    shapes.append(rect)
    if select:
        selection = [rect, ]
    update_gizmo()

    return rect



hierarchy_menu = Entity(parent=camera.ui, origin=[-.5,.5], xy=top_left, scale=[.1,.03], visible_self=False)
hierarchy_menu.bg = Entity(parent=hierarchy_menu, origin=[-.5,.5], scale=[1,10], color=color.black, alpha=.9, z=1)
hierarchy_menu.buttons = []
for i in range(24):
    b = Entity(parent=hierarchy_menu, origin=[-.5,.5], text=`${i}`, text_size=2, y=-i, roundness=.1, enabled=False)
    hierarchy_menu.buttons.append(b)

add_button = Button(parent=hierarchy_menu, text='+', origin=[-.5,.5], on_click=add_shape)

# def update_menu():
#     [e.enabled = False for e in hierarchy_menu.buttons]
#
#     for i, e in enumerate(shapes):
#         hierarchy_menu.buttons[i].enabled = True
#
#     add_button.y = -len(shapes)



def input(key):
    if key == 'a':
        add_shape()

    if key == 'left mouse down':
        if not mouse.hovered_entity and not held_keys['control']:
            print('clear selection')
            selection = []
            update_gizmo()
        else:
            print(mouse.hovered_entity)

        if mouse.hovered_entity and mouse.hovered_entity in shapes:
            if not held_keys['control']:
                selection = [mouse.hovered_entity, ]
                update_gizmo()


dragger = Entity(visible_self=True, alpha=.1, is_placing_clone=False, drop=def():position=[0,0,0] )
dragger.input = def dragger_input(key):
    if key == 'd' and selection:
        original = selection[-1]
        # dragger.position = [mouse.x+bg.x, mouse.y+bg.y]

        clone = add_shape(select=False)
        clone.parent = dragger
        clone.scale = original.scale
        clone.rotation = original.rotation
        clone.color = original.color
        clone.radius = original.radius

        dragger.lock_x = False
        dragger.lock_y = False
        # dragger.start_offset = [mouse.x-dragger.x-bg.x , mouse.y-dragger.y-bg.x]
        dragger.dragging = True
        dragger.is_placing_clone = True

    elif dragger.is_placing_clone and key == 'left mouse up':
        clone.parent = scene
        clone.x = dragger.x
        clone.y = dragger.y
        dragger.is_placing_clone = False
        dragger.position = [0,0,0]
        selection = [clone, ]
        update_gizmo()





target_zoom = 1
zoom_label = Button(text='100%', scale=[.075,.04], origin=[.5,.5], xy=[(.5*aspect_ratio)-.005,.495], color=hsv(0,0,0), text_color=hsv(0,0,.8), text_size=2, on_click=def():target_zoom=1)
zoom_label.update = def update():
    camera.fov = lerp(camera.fov, target_zoom, .1)


zoom_label.input = def zoom_input(key):
    if key == 'scroll up' and target_zoom > .3:
        target_zoom = target_zoom*.9
        # print(bg)
        zoom_label.text = `${int(target_zoom*100)}%`
    if key == 'scroll down' and target_zoom < 10:
        target_zoom = target_zoom*1/.9
        zoom_label.text = `${int(target_zoom*100)}%`

    if key == 'middle mouse down' or key == 'space':
        # mouse.start_drag_position = [mouse.x+camera.x*camera.fov, mouse.y+camera.y*camera.fov]
        # mouse.start_x = mouse.x
        # mouse.start_y = mouse.y
        # camera.start_x = camera.x
        # mouse.velocity = [0,0]
        mouse.prev_y = mouse.y
        mouse.velocity = [0, mouse.y-mouse.prev_y]
        panning = True

    #     bg.lock_x = False
    #     bg.lock_y = False
    #     bg.start_offset = [(mouse.x*camera.fov)-bg.x , (mouse.y*camera.fov)-bg.y]
    #     bg.dragging = True
    #
    if key == 'middle mouse up' or key == 'space up':
        mouse.prev_y = None
        # mouse.delta_drag = [0,0]
        panning = False

    #     mouse.start_drag_position = None

    #     bg.lock_x = True
    #     bg.lock_y = True
    #     bg.dragging = False
panning = False
camera.y = .1
mouse.prev_y = mouse.y
mouse.velocity = [mouse.y-mouse.prev_y, 0]
t = Button(text=`${mouse.velocity[0]}`)
panner = Entity(visible_self=False)
panner.update = def pan_update():
    if mouse.middle and panning:
        # mouse.delta_drag = [(mouse.x-mouse.start_x), mouse.y-mouse.start_y]
        mouse.velocity = [0, (mouse.y-mouse.prev_y)*camera.fov]
        t.text = `${mouse.velocity[1]}`
        print(mouse.velocity)
        t.fit_to_text()
        # camera.x = camera.start_x - (mouse.delta_drag[0]*camera.fov)
        camera.y = camera.y + 0
        # camera.x = mouse.start_drag_position[0] - (mouse.x+camera.x * camera.fov)
        # camera.y = mouse.start_drag_position[1] - (mouse.y+camera.y * camera.fov)
        mouse.prev_y = mouse.y


add_shape()


</script><script src="../taptapir/sunsnake_compiler.js"></script>
